\documentclass[lang=cn,newtx,10pt,scheme=chinese]{elegantbook}
\usepackage{realboxes}
\usepackage{forest}
\usepackage{import}
\usepackage{adjustbox}

\title{Linux设备驱动开发教程}
\author{左元}

\setcounter{tocdepth}{3}

\cover{cover.pdf}

% 本文档命令
\usepackage{array}
\newcommand{\ccr}[1]{\makecell{{\color{#1}\rule{1cm}{1cm}}}}

% 修改标题页的橙色带
\definecolor{customcolor}{RGB}{32,178,170}
\colorlet{coverlinecolor}{customcolor}
\usepackage{cprotect}

\newtcolorbox{marker}[1][]{enhanced,
  before skip=2mm,after skip=3mm,
  boxrule=0.4pt,left=5mm,right=2mm,top=1mm,bottom=1mm,
  colback=yellow!50,
  colframe=yellow!20!black,
  sharp corners,rounded corners=southeast,arc is angular,arc=3mm,
  underlay={%
    \path[fill=tcbcolback!80!black] ([yshift=3mm]interior.south east)--++(-0.4,-0.1)--++(0.1,-0.2);
    \path[draw=tcbcolframe,shorten <=-0.05mm,shorten >=-0.05mm] ([yshift=3mm]interior.south east)--++(-0.4,-0.1)--++(0.1,-0.2);
    \path[fill=yellow!50!black,draw=none] (interior.south west) rectangle node[white]{\Huge\bfseries !} ([xshift=4mm]interior.north west);
    },
  drop fuzzy shadow,#1}

\tcbuselibrary{listings, skins, breakable}
\usepackage[T1]{fontenc}
\usepackage[ttdefault=true]{AnonymousPro}
\definecolor{pblue}{rgb}{0.13,0.13,1}
\definecolor{pgreen}{rgb}{0,0.5,0}

\newtcblisting[auto counter, number within=chapter]{mycode}[1]{
    breakable,
    enhanced,
    attach boxed title to top right={yshift=-\tcboxedtitleheight},
    boxed title style={
        size=small,colback=gray!50,
        colframe=gray!50,
        sharp corners=downhill,
        arc=.5cm,
        top=1mm,bottom=1mm,left=1mm,right=1mm
    },
    fonttitle=\color{black}\itshape\ttfamily,
    colframe=gray!20,
    top=\tcboxedtitleheight,
    bottom=\tcboxedtitleheight,
    sharp corners=downhill,
    arc=.5cm,
    title={#1},
    listing only,
    listing options={
        escapeinside={(*@}{@*)},
        language=c,
        basicstyle=\fontfamily{AnonymousPro}\selectfont,
        keywordstyle=\bfseries\color{pblue},
        stringstyle=\bfseries\itshape\color{green!40!black},
        commentstyle=\bfseries\itshape\color{black!60},
        % Line numbers
        xleftmargin={0.75cm},
        numbers=left,
        stepnumber=1,
        firstnumber=1,
        numberfirstline=true,
        showspaces=false,
        showtabs=false,
        breaklines=true,
        showstringspaces=false,
        tabsize=1,
        emph={
            gpio_config_t, for, uint8_t, TextView, Toast, Button, EditText, ImageView, Typeface, Intent, WebView, WebSettings, SwipeRefreshLayout, RelativeLayout, Animation, AlertDialog, SharedPreferences, Editor, ToggleButton, CardView, LinearLayout, gradient, shape,
        },
        emphstyle={\bfseries\color{pblue}},
        frame=l
    }
}

\begin{document}

\maketitle
\frontmatter

\tableofcontents

\mainmatter

\part{Linux驱动}

\chapter{简介}

Linux内核是一种复杂、轻便、模块化并被广泛使用的软件。大约80\%的服务器和全世界一半以上设备的嵌入式系统上运行着Linux内核。设备驱动程序在整个Linux系统中起着至关重要的作用。由于Linux已成为非常流行的操作系统。

设备驱动程序通过内核在用户空间和设备之间建立连接。

Linux起源于芬兰的莱纳斯·托瓦尔兹（Linus Torvalds）在1991年凭个人爱好开创的一个项目。这个项目不断发展，至今全球有1000多名贡献者。现在，Linux已经成为嵌入式系统和服务器的必选。内核作为操作系统的核心，其开发不是一件容易的事。

和其他操作系统相比，Linux拥有更多的优点。

\begin{itemize}
\item 免费。
\item 丰富的文档和社区支持。
\item 跨平台移植。
\item 源代码开放。
\item 许多免费的开源软件。
\end{itemize}

本教程尽可能做到通用，但是仍然有些特殊的模块，比如设备树，目前在x86上没有完整实现。那么话题将专门针对ARM处理器，以及所有完全支持设备树的处理器。为什么选这两种架构？因为它们在桌面和服务器（x86）以及嵌入式系统（ARM）上得到广泛应用。

\section{环境配置}

在 Ubuntu 下，安装如下包。

\begin{mycode}{安装一些包}
$ sudo apt-get update
$ sudo apt-get install gawk wget git diffstat
unzip texinfo \
gcc-multilib build-essential chrpath socat
libsdl1.2-dev \
xterm ncurses-dev lzop
\end{mycode}

安装针对 ARM 体系结构的交叉编译器。

\begin{mycode}{安装交叉编译器}
$ sudo apt-get install gcc-arm-linux-gnueabihf
\end{mycode}

\subsection{获取源码}

在早期内核（2003年前）中，使用奇偶数对版本进行编号：奇数是稳定版，偶数是不稳定版。随着2.6版本的发布，版本编号方案切换为X.Y.Z格式。

\begin{itemize}
\item X：代表实际的内核版本，也被称为主版本号，当有向后不兼容的API更改时，它会递增。
\item Y：代表修订版本号，也被称作次版本号，在向后兼容的基础上增加新的功能后，它会递增。
\item Z：代表补丁，表示与错误修订相关的版本。
\end{itemize}

这就是所谓的语义版本编号方案，这种方案一直持续到2.6.39版本；当Linus Torvalds决定将版本升级到3.0时，意味着语义版本编号在2011年正式结束，然后采用的是X.Y版本编号方案。

升级到3.20版时，Linus认为不能再增加Y，决定改用随意版本编号方案：当Y值增加到手脚并用也数不过来时就递增X。这就是版本直接从3.20变化到4.0的原因。

现在内核使用的X.Y随意版本编号方案，这与语义版本编号无关。

\begin{marker}
Linus：仁慈的独裁者。
\end{marker}

\textbf{源代码的组织}

必须使用Linus Torvald的Github仓库。

\begin{mycode}{下载源码}
$ git clone https://github.com/torvalds/linux
$ git checkout 版本号 # 例如：git checkout v4.1
$ ls
\end{mycode}

内核中各文件夹的含义：

\begin{itemize}
    \item arch/：Linux内核是一个快速增长的工程，支持越来越多的体系结构。这意味着，内核尽可能通用。与体系结构相关的代码被分离出来，并放入此目录中。该目录包含与处理器相关的子目录，例如alpha/、arm/、mips/、blackfin/等。
    \item block/：该目录包含块存储设备代码，实际上也就是I/O调度算法。
    \item crypto/：该目录包含密码API和加密算法代码。
    \item Documentation/：这应该是最受欢迎的目录。它包含不同内核框架和子系统所使用API的描述。在论坛发起提问之前，应该先看这里。
    \item drivers/：这是最重的目录，不断增加的设备驱动程序都被合并到这个目录，不同的子目录中包含不同的设备驱动程序。
    \item fs/：该目录包含内核支持的不同文件系统的实现，诸如NTFS、FAT、ETX\{2,3,4\}、sysfs、procfs、NFS等。
    \item include/：该目录包含内核头文件。
    \item init/：该目录包含初始化和启动代码。
    \item ipc/：该目录包含进程间通信（IPC）机制的实现，如消息队列、信号量和共享内存。
    \item kernel/：该目录包含基本内核中与体系结构无关的部分。
    \item lib/：该目录包含库函数和一些辅助函数，分别是通用内核对象（kobject）处理程序和循环冗余码（CRC）计算函数等。
    \item mm/：该目录包含内存管理相关代码。
    \item net/：该目录包含网络（无论什么类型的网络）协议相关代码。
    \item scripts/：该目录包含在内核开发过程中使用的脚本和工具，还有其他有用的工具。
    \item security/：该目录包含安全框架相关代码。
    \item sound/：该目录包含音频子系统代码。
    \item usr/：该目录目前包含了initramfs的实现。
\end{itemize}

内核必须保持它的可移植性。任何体系结构特定的代码都应该位于arch目录中。当然，与用户空间API相关的内核代码不会改变（系统调用、/proc、/sys），因为它会破坏现有的程序。

\subsection{内核配置}

Linux内核是一个基于makefile的工程，有1000多个选项和驱动程序。配置内核可以使用基于ncurse的接口命令\Colorbox{lightgrey}{\lstinline{make menuconfig}}，也可以使用基于X的接口命令make xconfig。一旦选择，所有选项会被存储到源代码根目录下的\Colorbox{lightgrey}{\lstinline{.config}}文件中。

大多情况下不需要从头开始配置。每个arch目录下面都有默认的配置文件可用，可以把它们用作配置起点：

\begin{mycode}{列出配置文件}
$ ls arch/<you_arch>/configs/
\end{mycode}

对于基于ARM的CPU，这些配置文件位于\Colorbox{lightgrey}{\lstinline{arch/arm/configs/}}；

对于基于V3S处理器的Atguigu派，默认的配置文件位于\Colorbox{lightgrey}{\lstinline{arch/arm/configs/atguigupi_defconfig}}；

类似地，对于x86处理器，可以在\Colorbox{lightgrey}{\lstinline{arch/x86/configs/}}找到配置文件，仅有两个默认配置文件：

\begin{itemize}
\item \Colorbox{lightgrey}{\lstinline{i386_defconfig}}: 32位版本
\item \Colorbox{lightgrey}{\lstinline{x86_64_defconfig}}: 64位版本
\end{itemize}

对x86系统，内核配置非常简单：

\begin{mycode}{内核配置}
$ make x86_64_defconfig
$ make zImage -j16
$ make modules
$ makeINSTALL_MOD_PATH </where/to/install>
$ modules_install
\end{mycode}

对于基于V3S的开发板AtguiguPI：

可以先执行\Colorbox{lightgrey}{\lstinline{ARCH=arm make atguigupi_defconfig}}，然后执行\Colorbox{lightgrey}{\lstinline{ARCH=arm make menuconfig}}。前一个命令把默认的内核选项存储到\Colorbox{lightgrey}{\lstinline{.config}}文件中；后一个命令则根据需求来更新、增加或者删除选项。

\subsection{构建自己的内核}

构建自己的内核需要指定相关的体系结构和编译器。

\begin{mycode}{交叉编译}
$ ARCH=arm make atguigupi_defconfig
$ ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- make zImage -j16
\end{mycode}

内核构建完成后，会在\Colorbox{lightgrey}{\lstinline{arch/arm/boot/}}下生成一个单独的二进制映像文件。使用下列命令构建模块：

\begin{mycode}{构建模块}
$ ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- make modules
\end{mycode}

可以通过下列命令安装编译好的模块：

\begin{mycode}{安装模块}
$ ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- make modules_install
\end{mycode}

\Colorbox{lightgrey}{\lstinline{modules_install}}目标需要指定一个环境变量\Colorbox{lightgrey}{\lstinline{INSTALL_MOD_PATH}}，指出模块安装的目录。如果没有设置，则所有的模块将会被安装到\Colorbox{lightgrey}{\lstinline{/lib/modules/$(KERNELRELEASE)/kernel/}}目录下，具体细节将会在第2章讨论。

V3S处理器支持设备树，设备树是一些文件，可以用来描述硬件（相关细节会在第6章介绍）。无论如何，运行下列命令可以编译所有ARCH设备树：

\begin{mycode}{编译所有设备树}
$ ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- make dtbs
\end{mycode}

然而，dtbs选项不一定适用于所有支持设备树的平台。要构建一个单独的DTB，应该执行下列命令：

\begin{mycode}{单独编译DTB文件}
$ ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- make atguigupi.dtb
\end{mycode}

\section{内核代码编写风格}

深入学习本节之前应该先参考一下内核编码风格手册，它位于内核源代码树的Documentation/CodingStyle目录下。编码风格是应该遵循的一套规则，如果想要内核开发人员接受其补丁就应该遵守这一规则。其中一些规则涉及缩进、程序流程、命名约定等。

常见的规则如下。

\begin{itemize}
    \item 始终使用8个字符的制表符缩进，每一行不能超过80个字符。如果缩进妨碍函数书写，那只能说明嵌套层次太多了。
    \item 每一个不被导出的函数或变量都必须声明为静态的（static）。
    \item 在带括号表达式的内部两端不要添加空格。
    
    \Colorbox{lightgrey}{\lstinline{s = sizeof(struct file);}}是可以接受的，
    
    而\Colorbox{lightgrey}{\lstinline{s = sizeof( struct file );}}是不被接受的。
    \item 禁止使用\Colorbox{lightgrey}{\lstinline{typedef}}。
    \item 请使用\Colorbox{lightgrey}{\lstinline{/* this */}}注释风格，不要使用\Colorbox{lightgrey}{\lstinline{// this}}。
    \item 宏定义应该大写，但函数宏可以小写。
    \item 不要试图用注释去解释一段难以阅读的代码。应该重写代码，而不是添加注释。
\end{itemize}

\section{内核结构分配和初始化}

内核总是为其数据结构和函数提供两种可能的分配机制。

下面是其中的一些数据结构。

\begin{itemize}
\item 工作队列。
\item 列表。
\item 等待队列。
\item Tasklet。
\item 定时器。
\item 完成量。
\item 互斥锁。
\item 自旋锁。
\end{itemize}

动态初始化器是通过宏定义实现的，因此全用大写：

\begin{itemize}
    \item \Colorbox{lightgrey}{\lstinline{INIT_LIST_HEAD()}}
    \item \Colorbox{lightgrey}{\lstinline{DECLARE_WAIT_QUEUE_HEAD()}}
    \item \Colorbox{lightgrey}{\lstinline{DECLARE_TASKLET()}}
    \item 等等
\end{itemize}

表示框架设备的数据结构总是动态分配的，每个都有其自己的分配和释放API。框架设备类型如下。

\begin{itemize}
\item 网络设备。
\item 输入设备。
\item 字符设备。
\item IIO设备。
\item 类设备。
\item 帧缓冲。
\item 调节器。
\item PWM设备。
\item RTC。
\end{itemize}

静态对象在整个驱动程序范围内都是可见的，并且通过该驱动程序管理的每个设备也是可见的。而动态分配对象则只对实际使用该模块特定实例的设备可见。

\section{类、对象、面向对象的编程}

内核通过类和设备实现面向对象的编程。内核子系统被抽象成类，有多少子系统，\Colorbox{lightgrey}{\lstinline{/sys/class/}}下几乎就有多少个目录。\Colorbox{lightgrey}{\lstinline{struct kobject}}结构是整个实现的核心，它包含一个引用计数器，以便于内核统计有多少用户使用了这个对象。每个对象都有一个父对象，在\Colorbox{lightgrey}{\lstinline{sysfs}}（加载之后）中会有一项。

属于给定子系统的每个设备都有一个指向\Colorbox{lightgrey}{\lstinline{operations(ops)}}结构的指针，该结构提供一组可以在此设备上执行的操作。

\chapter{设备驱动程序基础}

驱动程序是专用于控制和管理特定硬件设备的软件，因此也被称作设备驱动程序。从操作系统的角度来看，它可以位于内核空间（以特权模式运行），也可以位于用户空间（具有较低的权限）。本教程仅涉及内核空间驱动程序，特别是Linux内核驱动程序。我们给出的定义是，设备驱动程序把硬件功能提供给用户程序。

本章涉及以下主题。

\begin{itemize}
\item 模块构建过程及其加载和卸载。
\item 驱动程序框架以及调试消息管理。
\item 驱动程序中的错误处理。
\end{itemize}

\section{内核空间和用户空间}

内核空间和用户空间的概念有点抽象，主要涉及内存和访问权限，如图\ref{fig:内核空间和用户空间示意图}所示。可以这样认为：内核是有特权的，而用户应用程序则是受限制的。这是现代CPU的一项功能，它可以运行在特权模式或非特权模式。学习第11章之后，这个概念会更加清晰。

图\ref{fig:内核空间和用户空间示意图}说明内核空间和用户空间的分离，并强调了系统调用代表它们之间的桥梁（将在本章后面讨论）。每个空间的描述如下。

\begin{itemize}
    \item 内核空间：内核驻留和运行的地址空间。内核内存（或内核空间）是由内核拥有的内存范围，受访问标志保护，防止任何用户应用程序有意或无意间与内核搞混。另一方面，内核可以访问整个系统内存，因为它在系统上以更高的优先级运行。在内核模式下，CPU可以访问整个内存（内核空间和用户空间）。
    \item 用户空间：正常程序（如vim等）被限制运行的地址（位置）空间。可以将其视为沙盒或监狱，以便用户程序不能混用其他程序拥有的内存或任何其他资源。在用户模式下，CPU只能访问标有用户空间访问权限的内存。用户应用程序运行到内核空间的唯一方法是通过系统调用，其中一些调用是read、write、open、close和mmap等。用户空间代码以较低的优先级运行。当进程执行系统调用时，软件中断被发送到内核，这将打开特权模式，以便该进程可以在内核空间中运行。系统调用返回时，内核关闭特权模式，进程再次受限。
\end{itemize}

\begin{figure}[!htbp]
\centering


\tikzset{every picture/.style={line width=0.75pt}} %set default line width to 0.75pt        

\scalebox{0.5}{
\begin{tikzpicture}[x=0.75pt,y=0.75pt,yscale=-1,xscale=1]
%uncomment if require: \path (0,730); %set diagram left start at 0, and has height of 730

%Shape: Rectangle [id:dp5729309877688962] 
\draw  [fill={rgb, 255:red, 74; green, 144; blue, 226 }  ,fill opacity=1 ] (32,30) -- (360,30) -- (360,463) -- (32,463) -- cycle ;
%Shape: Circle [id:dp4146631065291506] 
\draw  [fill={rgb, 255:red, 248; green, 231; blue, 28 }  ,fill opacity=1 ] (74,147.5) .. controls (74,119.61) and (96.61,97) .. (124.5,97) .. controls (152.39,97) and (175,119.61) .. (175,147.5) .. controls (175,175.39) and (152.39,198) .. (124.5,198) .. controls (96.61,198) and (74,175.39) .. (74,147.5) -- cycle ;
%Shape: Circle [id:dp43936873023108314] 
\draw  [fill={rgb, 255:red, 248; green, 231; blue, 28 }  ,fill opacity=1 ] (153,257.5) .. controls (153,229.61) and (175.61,207) .. (203.5,207) .. controls (231.39,207) and (254,229.61) .. (254,257.5) .. controls (254,285.39) and (231.39,308) .. (203.5,308) .. controls (175.61,308) and (153,285.39) .. (153,257.5) -- cycle ;
%Shape: Circle [id:dp42297673065034025] 
\draw  [fill={rgb, 255:red, 248; green, 231; blue, 28 }  ,fill opacity=1 ] (52,353.5) .. controls (52,325.61) and (74.61,303) .. (102.5,303) .. controls (130.39,303) and (153,325.61) .. (153,353.5) .. controls (153,381.39) and (130.39,404) .. (102.5,404) .. controls (74.61,404) and (52,381.39) .. (52,353.5) -- cycle ;
%Straight Lines [id:da07292076668851943] 
\draw    (279,31) -- (279,464) ;
%Shape: Rectangle [id:dp27802170297701934] 
\draw  [fill={rgb, 255:red, 245; green, 166; blue, 35 }  ,fill opacity=1 ] (516,172) -- (872,172) -- (872,352) -- (516,352) -- cycle ;
%Straight Lines [id:da4208187953232636] 
\draw    (360,199) -- (516,199.99) ;
\draw [shift={(518,200)}, rotate = 180.36] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (10.93,-3.29) .. controls (6.95,-1.4) and (3.31,-0.3) .. (0,0) .. controls (3.31,0.3) and (6.95,1.4) .. (10.93,3.29)   ;
%Straight Lines [id:da8337848177774614] 
\draw    (517,316) -- (361,314.03) ;
\draw [shift={(359,314)}, rotate = 0.73] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (10.93,-3.29) .. controls (6.95,-1.4) and (3.31,-0.3) .. (0,0) .. controls (3.31,0.3) and (6.95,1.4) .. (10.93,3.29)   ;
%Shape: Rectangle [id:dp44675008718689546] 
\draw  [fill={rgb, 255:red, 184; green, 233; blue, 134 }  ,fill opacity=1 ] (872,132) -- (942,132) -- (942,422) -- (872,422) -- cycle ;

% Text Node
\draw (102,137) node [anchor=north west][inner sep=0.75pt]   [align=left] {进程A};
% Text Node
\draw (181,246.5) node [anchor=north west][inner sep=0.75pt]   [align=left] {进程B};
% Text Node
\draw (85,343) node [anchor=north west][inner sep=0.75pt]   [align=left] {进程C};
% Text Node
\draw (303,239) node [anchor=north west][inner sep=0.75pt]   [align=left] {lib c};
% Text Node
\draw (104,56) node [anchor=north west][inner sep=0.75pt]   [align=left] {用户空间};
% Text Node
\draw (667,257) node [anchor=north west][inner sep=0.75pt]   [align=left] {内核空间};
% Text Node
\draw (395,202) node [anchor=north west][inner sep=0.75pt]   [align=left] {系统调用：\\open\\write\\read\\...};
% Text Node
\draw (884,213) node [anchor=north west][inner sep=0.75pt]   [align=left] {硬件：\\内存\\硬盘\\视频卡\\...};

\end{tikzpicture}}

\caption{内核空间和用户空间示意图}
\label{fig:内核空间和用户空间示意图}
\end{figure}

\subsection{模块的概念}

模块之于Linux内核就像插件（组件）之于用户软件（如Firefox），模块动态扩展了内核功能，甚至不需要重新启动计算机就可以使用。大多数情况下，内核模块是即插即用的。一旦插入，就可以使用了。为了支持模块，构建内核时必须启用下面的选项：

\begin{mycode}{支持模块}
CONFIG_MODULES=y
\end{mycode}

\subsection{模块依赖}

Linux内核中的模块可以提供函数或变量，用EXPORT\_SYMBOL宏导出它们即可供其他模块使用，这些被称作符号。模块B对模块A的依赖是指模块B使用从模块A导出的符号。

在内核构建过程中运行depmod工具可以生成模块依赖文件。

它读取\Colorbox{lightgrey}{\lstinline{/lib/modules/<kernel_release>/}}中的每个模块来确定它应该导出哪些符号以及它需要什么符号。

该处理的结果写入文件modules.dep及其二进制版本modules.dep.bin。它是一种模块索引。

\subsection{模块的加载和卸载}

模块要运行，应该先把它加载到内核，可以用insmod或modprobe来实现，前者需要指定模块路径作为参数，这是开发期间的首选；后者更智能化，是生产系统中的首选。

\begin{enumerate}
    \item 手动加载。
    
    手动加载需要用户的干预，该用户应该拥有root访问权限。实现这一点的两种经典方法如下。

    在开发过程中，通常使用insmod来加载模块，并且应该给出所加载模块的路径：

    \begin{mycode}{insmod加载模块}
        $ insmod /path/to/mydrv.ko
    \end{mycode}

    这种模块加载形式低级，但它是其他模块加载方法的基础，也是本教程中将要使用的方法。相反，系统管理员或在生产系统中则常用modprobe。modprobe更智能，它在加载指定的模块之前解析文件modules.dep，以便首先加载依赖关系。它会自动处理模块依赖关系，就像包管理器所做的那样：

    \begin{mycode}{modprobe加载模块}
        $ modprobe mydrv
    \end{mycode}

    能否使用modprobe取决于depmod是否知道模块的安装。

    \begin{mycode}{能否使用modprobe}
        $ /etc/modules-load.d/<filename>.conf
    \end{mycode}

    如果要在启动的时候加载一些模块，则只需创建文件\Colorbox{lightgrey}{\lstinline{/etc/modules-load.d/<filename>.conf}}，并添加应该加载的模块名称（每行一个）。
    
    \Colorbox{lightgrey}{\lstinline{<filename>}}应该是有意义的名称，人们通常使用模块：\Colorbox{lightgrey}{\lstinline{/etc/modules-load.d/modules.conf}}。
    
    当然也可以根据需要创建多个\Colorbox{lightgrey}{\lstinline{.conf}}文件。
    
    下面是一个\Colorbox{lightgrey}{\lstinline{/etc/modules-load.d/mymodules.conf}}文件中的内容：

    \begin{mycode}{配置文件示例}
        #this line is a comment
        uio
        iwlwifi
    \end{mycode}

    \item 自动加载
    
    depmod实用程序的作用不只是构建modules.dep和modules.dep.bin文件。内核开发人员实际编写驱动程序时已经确切知道该驱动程序将要支持的硬件。他们把驱动程序支持的所有设备的产品和厂商ID提供给该驱动程序。
    
    depmod还处理模块文件以提取和收集该信息，并在/lib/modules/<kernel\_release>/modules.alias中生成modules.alias文件，该文件将设备映射到其对应的驱动程序。

    下面的内容摘自modules.alias：

    \begin{mycode}{modules.alias}
        alias usb:v0403pFF1Cd*dc*dsc*dp*ic*isc*ip*in* ftdi_sio
        alias usb:v0403pFF18d*dc*dsc*dp*ic*isc*ip*in* ftdi_sio
        alias usb:v0403pDAFFd*dc*dsc*dp*ic*isc*ip*in* ftdi_sio
        alias usb:v0403pDAFEd*dc*dsc*dp*ic*isc*ip*in* ftdi_sio
        alias usb:v0403pDAFDd*dc*dsc*dp*ic*isc*ip*in* ftdi_sio
        alias usb:v0403pDAFCd*dc*dsc*dp*ic*isc*ip*in* ftdi_sio
        alias usb:v0D8Cp0103d*dc*dsc*dp*ic*isc*ip*in* snd_usb_audio
        alias usb:v*p*d*dc*dsc*dp*ic01isc03ip*in* snd_usb_audio
        alias usb:v200Cp100Bd*dc*dsc*dp*ic*isc*ip*in* snd_usb_au
    \end{mycode}

    在这一步，需要一个用户空间热插拔代理（或设备管理器），通常是udev（或mdev），它将在内核中注册，以便在出现新设备时得到通知。
    
    通知由内核发布，它将设备描述（pid、vid、类、设备类、设备子类、接口以及可标识设备的所有其他信息）发送到热插拔守护进程，守护进程再调用modprobe，并向其传递设备描述信息。接下来，modprobe解析modules.alias文件，匹配与该设备相关的驱动程序。在加载模块之前，modprobe会在module.dep中查找与其有依赖关系的模块。如果发现，则在相关模块加载之前先加载所有依赖模块；否则，直接加载该模块。

    \item 模块卸载
    
    常用的模块卸载命令是rmmod，人们更喜欢用这个来卸载insmod命令加载的模块。使用该命令时，应该把要卸载的模块名作为参数向其传递。
    
    模块卸载是内核的一项功能，该功能的启用或禁用由CONFIG\_MODULE\_UNLOAD配置选项的值决定。没有这个选项，就不能卸载任何模块。以下设置将启用模块卸载功能：

    \begin{mycode}{模块卸载配置}
        CONFIG_MODULE_UNLOAD=y
    \end{mycode}

    在运行时，如果模块卸载会导致其他不良影响，则即使有人要求卸载，内核也将阻止这样做。这是因为内核通过引用计数记录模块的使用次数，这样它就知道模块是否在用。如果内核认为删除一个模块是不安全的，就不会删除它。然而，以下设置可以改变这种行为：

    \begin{mycode}{强制卸载模块配置}
        MODULE_FORCE_UNLOAD=y
    \end{mycode}

    上面的选项应该在内核配置中设置，以强制卸载模块：

    \begin{mycode}{强制卸载模块}
        rmmod -f mymodule
    \end{mycode}

    而另一个更高级的模块卸载命令是\Colorbox{lightgrey}{\lstinline{modeprobe -r}}，它会自动卸载未使用的相关依赖模块：

    \begin{mycode}{自动卸载相关依赖}
        modeprobe -r mymodule
    \end{mycode}

    这对于开发者来说是一个非常有用的选择。用下列命令可以检查模块是否已加载：

    \begin{mycode}{列出模块}
        lsmod
    \end{mycode}
\end{enumerate}

\section{驱动程序框架}

\begin{mycode}{helloworld.c}
#include <linux/init.h>
#include <linux/module.h>
#include <linux/kernel.h>

static int __init helloworld_init(void) {
    pr_info("Hello world!\n");
    return 0;
}

static void __exit helloworld_exit(void) {
    pr_info("End of the world\n");
}

module_init(helloworld_init);
module_exit(helloworld_exit);
MODULE_AUTHOR("Yuan Zuo <zuoyuantc@gmail.com>");
MODULE_LICENSE("GPL");
\end{mycode}

\subsection{模块的入口点和出口点}

内核驱动程序都有入口点和出口点：前者对应于模块加载时调用的函数（modprobe和insmod），后者是模块卸载时执行的函数（在执行rmmod或modprobe -r时）。

main()函数是用C/C++编写的每个用户空间程序的入口点，当这个函数返回时，程序将退出。而对于内核模块，情况就不一样了：入口点可以随意命名，它也不像用户空间程序那样在main()返回时退出，其出点在另一个函数中定义。开发人员要做的就是通知内核把哪些函数作为入口点或出口点来执行。实际函数hellowolrd\_init和hellowolrd\_exit可以被命名成任何名字。实际上，唯一必须要做的是把它们作为参数提供给module\_init()和module\_exit()宏，将它们标识为相应的加载和删除函数。

综上所述，module\_init()用于声明模块加载（使用insmod或modprobe）时应该调用的函数。初始化函数中要完成的操作是定义模块的行为。module\_exit()用于声明模块卸载（使用rmmod）时应该调用的函数。

\begin{marker}
在模块加载或卸载后，init函数或exit函数立即运行一次。
\end{marker}

\Colorbox{lightgrey}{\lstinline{__init和__exit属性}}

\Colorbox{lightgrey}{\lstinline{__init}}和\Colorbox{lightgrey}{\lstinline{__exit}}实际上是在include/linux/init.h中定义的内核宏，如下所示：

\begin{mycode}{宏定义}
#define __init __section(.init.text)
#define __exit __section(.exit.text)
\end{mycode}

\Colorbox{lightgrey}{\lstinline{__init}}关键字告诉链接器将该代码放在内核对象文件的专用部分。这部分事先为内核所知，它在模块加载和init函数执行后被释放。这仅适用于内置驱动程序，而不适用于可加载模块。内核在启动过程中第一次运行驱动程序的初始化函数。

由于驱动程序不能卸载，因此在下次重启之前不会再调用其init函数，没有必要在init函数内记录引用次数。对于\Colorbox{lightgrey}{\lstinline{__exit}}关键字也是如此，在将模块静态编译到内核或未启用模块卸载功能时，其相应的代码会被忽略，因为在这两种情况下都不会调用exit函数。\Colorbox{lightgrey}{\lstinline{__exit}}对可加载模块没有影响。

我们花一点时间进一步了解这些属性的工作方式，这涉及被称作可执行和可链接格式（ELF）的目标文件。ELF目标文件由不同的命名部分组成，其中一些部分是必需的，它们成为ELF标准的基础，但也可以根据自己的需要构建任一部分，并由特殊程序使用。内核就是这样做。执行\Colorbox{lightgrey}{\lstinline{objdump -h module.ko}}即可打印出指定内核模块module.ko的不同组成部分。

打印内容只有少部分属于ELF标准。

\begin{itemize}
\item .text：包含程序代码，也称为代码。
\item .data：包含初始化数据，也称为数据段。
\item .rodata：用于只读数据。
\item .comment：注释。
\item 未初始化的数据段，也称为由符号开始的块（block started by symbol，bss）。
\end{itemize}

其他部分是根据内核的需要添加的。本章较重要的部分是.modeinfo和.init.text，前者存储有关模块的信息，后者存储以\_\_init宏为前缀的代码。

链接器（Linux系统上的ld）是binutils的一部分，负责将符号（数据、代码等）放置到生成的二进制文件中的适当部分，以便在程序执行时可以被加载器处理。二进制文件中的这些部分可以自定义、更改它们的默认位置，甚至可以通过提供链接器脚本[称为链接器定义文件（LDF）或链接器定义脚本（LDS）]来添加其他部分。要实现这些操作只需通过编译器指令把符号的位置告知链接器即可，GNU C编译器为此提供了一些属性。Linux内核提供了一个自定义LDS文件，它位于arch/<arch>/kernel/vmlinux.lds.S中。对于要放置在内核LDS文件所映射的专用部分中的符号，使用\_\_init和\_\_exit进行标记。

总之，\_\_init和\_\_exit是Linux指令（实际上是宏），它们使用C编译器属性指定符号的位置。这些指令指示编译器将以它们为前缀的代码分别放在.init.text和.exit.text部分，虽然内核可以访问不同的对象部分。

\subsection{模块信息}

即使不读代码，也应该能够收集到关于给定模块的一些信息（如作者、参数描述、许可）。内核模块使用其.modinfo部分来存储关于模块的信息，所有MODULE\_*宏都用参数传递的值更新这部分的内容。其中一些宏是MODULE\_DESCRIPTION()、MODULE\_AUTHOR()和MODULE\_LICENSE()。内核提供的在模块信息部分添加条目的真正底层宏是MODULE\_INFO(tag,info)，它添加的一般信息形式是tag=info。这意味着驱动程序作者可以自由添加其想要的任何形式信息，例如：

\begin{mycode}{作者信息}
MODULE_INFO(my_field_name, "What eeasy value");
\end{mycode}

在给定模块上执行\Colorbox{lightgrey}{\lstinline{objdump -d -j .modinfo}}命令可以转储内核模块.modeinfo部分的内容，如图2-3所示。

modinfo部分可以看作模块的数据表。实际格式化打印信息的用户空间工具是modinfo，如图2-4所示。

除自定义信息之外，还应该提供标准信息，内核为这些信息提供了宏，包括许可、模块作者、参数描述、模块版本和模块描述。

1. 许可

模块的许可由MODULE\_LICENSE()宏定义：

\begin{mycode}{许可}
MODULE_LICENSE ("GPL");
\end{mycode}

应该如何与其他开发人员共享(或不共享)许可定义源代码。MODULE\_LICENSE()告诉内核模块采用何种许可。它对模块行为有影响，因为与GPL不兼容的许可将导致模块不能通过EXPORT\_SYMBOL\_GPL()宏看到/使用内核导出的服务/函数，这个宏只对GPL兼容模块显示符号，这与EXPORT\_SYMBOL()相反，后者为具有任何许可的模块导出函数。加载GPL不兼容模块也会导致内核被污染，这意味着已经加载非开源或不可信代码，可能没有社区支持。请记住，没有MODULE\_LICENSE()的模块被认为是非开源的，也会污染内核。以下摘自include/linux/module.h，描述了内核支持的许可：

\begin{mycode}{内核支持的许可}
/*
* The following license indents are currently accepted as indicating free
* software modules
*
* "GPL"                              [GNU Public License v2 or later]
* "GPL v2"                           [GNU Public License v2]
* "GPL and additional rights"        [GNU Public License v2 rights and more]
* "Dual BSD/GPL"                     [GNU Public License v2 or BSD license choice]
* "Dual MIT/GPL"                     [GNU Public License v2 or MIT license choice]
* "Dual MPL/GPL"                     [GNU Public License v2 or Mozilla license choice]
*
* The following other idents are available
*
* "Proprietary"                      [Non free products]
*
* There are dual licensed components, but when running with Linux it is the
* GPL that is relevant so this is a non issue. Similarly LGPL linked with GPL
* is a GPL combined work.
*
* This exists for several reasons
* 1. So modinfo can show license info for users wanting to vet their setup is free
* 2. So the community can ignore bug reports including proprietary modules
* 3. So vendors can do likewise based on their own policies
*/
\end{mycode}

\begin{marker}
    模块至少必须与GPL兼容，才能享受完整的内核服务。
\end{marker}

2. 模块作者

MODULE\_AUTHOR()声明模块的作者：

\begin{mycode}{模块作者}
MODULE_AUTHOR("John Madieu <john.madieu@gmail.com>");
\end{mycode}

作者可能有多个，在这种情况下，每个作者必须用MODULE\_AUTHOR()声明：

\begin{mycode}{多个模块作者}
MODULE_AUTHOR("John Madieu <john.madieu@gmail.com>");
MODULE_AUTHOR("Lorem Ipsum <l.ipsum@foobar.com>");
\end{mycode}

3. 模块描述

MODULE\_DESCRIPTION()简要描述模块的功能：

\begin{mycode}{模块描述}
MODULE_DESCRIPTION("Hello, world! Module");
\end{mycode}

\section{错误和消息打印}

错误代码由内核或用户空间应用程序(通过errno变量)解释。错误处理在软件开发中非常重要,而不仅仅是在内核开发中。幸运的是,内核提供的几种错误,几乎涵盖了可能会遇到的所有错误,有时需要把它们打印出来以帮助进行调试。

\subsection{错误处理}

为给定的错误返回错误代码会导致内核或用户空间应用产生不必要的行为,从而做出错误的决定。为了保持清楚,内核树中预定义的错误几乎涵盖了我们可能遇到的所有情况。

一些错误(及其含义)在include/uapi/asm-generic/errno-base.h中定义,列表的其余错误可以在include/uapi/asm-generic/errno.h中找到。

以下是从include/uapi/asm-generic/errno-base.h中摘录的错误列表:

\begin{mycode}{错误编码}
#define  EPERM       1    /* 操作不允许 */
#define  ENOENT      2    /* 没有这样的文件或者目录 */
#define  ESRCH       3    /* 没有这样的进程 */
#define  EINTR       4    /* 中断系统调用 */
#define  EIO         5    /* I/O错误 */
#define  ENXIO       6    /* 没有这样的设备或地址 */
#define  E2BIG       7    /* 参数列表太长 */
#define  ENOEXEC     8    /* Exec格式错误 */
#define  EBADF       9    /* 错误的文件数量*/
#define  ECHILD      10   /* 没有子进程 */
#define  EAGAIN      11   /* 再试一次 */
#define  ENOMEM      12   /* 内存不足 */
#define  EACCES      13   /* 没有权限 */
#define  EFAULT      14   /* 错误的地址 */
#define  ENOTBLK     15   /* 块设备要求*/
#define  EBUSY       16   /* 设备或资源忙 */
#define  EEXIST      17   /* 文件已存在 */
#define  EXDEV       18   /* 跨设备的链接 */
#define  ENODEV      19   /* 没有这样的设备 */
#define  ENOTDIR     20   /* 不是目录 */
#define  EISDIR      21   /* 是目录 */
#define  EINVAL      22   /* 无效参数 */
#define  ENFILE      23   /* 文件表溢出*/
#define  EMFILE      24   /* 打开的文件太多 */
#define  ENOTTY      25   /* 不是打字机 */
#define  ETXTBSY     26   /* 文本文件忙 */
#define  EFBIG       27   /* 文件太大 */
#define  ENOSPC      28   /* 设备上没有空间了 */
#define  ESPIPE      29   /* 非法寻求 */
#define  EROFS       30   /* 只读文件系统 */
#define  EMLINK      31   /* 链接太多 */
#define  EPIPE       32   /* 破坏的管道 */
#define  EDOM        33   /* 函数域外的数学参数 */
#define  ERANGE      34   /* 数学结果无法表示 */
\end{mycode}

大多情况下,经典的返回错误方式是这种形式:return -ERROR,特别是在响应系统调用时。例如,对于I/O错误,错误代码是EIO,应该执行的语句是return -EIO:

\begin{mycode}{错误返回}
dev = init(&ptr);
if (!dev)
    return -EIO;
\end{mycode}

错误有时会跨越内核空间,传播到用户空间。如果返回的错误是对系统调用(open、read、ioctl、mmap)的响应,则该值将自动赋给用户空间errno全局变量,在该变量上调用strerror(errno)可以将错误转换为可读字符串:

\begin{mycode}{code}
#include <errno.h> /* to access errno global variable */
#include <string.h>
[...]
if(write(fd, buf, 1) < 0) {
    printf("something gone wrong! %s\n", strerror(errno));
}
[...]
\end{mycode}

当遇到错误时,必须撤销在这个错误发生之前的所有设置。通常的做法是使用goto语句:

\begin{mycode}{使用goto进行错误处理}
ptr = kmalloc(sizeof (device_t));
if(!ptr) {
    ret = -ENOMEM;
    goto err_alloc;
}

dev = init(&ptr);

if(dev) {
    ret = -EIO
    goto err_init;
}

return 0;

err_init:
    free(ptr);
err_alloc:
    return ret;
\end{mycode}

使用goto语句的原因很简单。当处理错误时,假设错误出现在第5步,则必须清除以前的操作(步骤1~步骤4)。而不是像下面这样执行大量的嵌套检查操作:

\begin{mycode}{嵌套处理}
if (ops1() != ERR) {
    if (ops2() != ERR) {
        if ( ops3() != ERR) {
            if (ops4() != ERR) {
\end{mycode}

这可能会令人困惑,并可能导致缩进问题。像下面这样用goto语句会使控制流程显得更直观,这种方法更受欢迎:

\begin{mycode}{goto处理错误}
if (ops1() == ERR) // |
    goto error1;   // |
if (ops2() == ERR) // |
    goto error2;   // |
if (ops3() == ERR) // |
    goto error3;   // |
if (ops4() == ERR) // V
    goto error4;
error5:
[...]
error4:
[...]
error3:
[...]
error2:
[...]
error1:
[...]
\end{mycode}

这就是说应该只在函数中使用goto跳转。

\subsection{处理空指针错误}

当返回指针的函数返回错误时,通常返回的是NULL指针。而去检查为什么会返回空指针是没有任何意义的,因为无法准确了解为什么会返回空指针。为此,内核提供了3个函数ERR\_PTR、IS\_ERR和PTR\_ERR:

\begin{mycode}{处理空指针错误}
void *ERR_PTR(long error);
long IS_ERR(const void *ptr);
long PTR_ERR(const void *ptr);
\end{mycode}

第一个函数实际上把错误值作为指针返回。假若函数在内存申请失败后要执行语句return -ENOMEM,则必须改为这样的语句:return ERR\_PTR (-ENOMEM);。

第二个函数用于检查返回值是否是指针错误:if(IS\_ERR(foo))。最后一个函数返回实际错误代码:return PTR\_ERR(foo);。以下是一个例子,说明如何使用ERR\_PTR、IS\_ERR和PTR\_ERR:

\begin{mycode}{example}
static struct iio_dev *indiodev_setup(){
    [...]
    struct iio_dev *indio_dev;
    indio_dev = devm_iio_device_alloc(&data->client->dev, sizeof(data));
    if (!indio_dev)
        return ERR_PTR(-ENOMEM);
    [...]
    return indio_dev;
}

static int foo_probe([...]){
    [...]
    struct iio_dev *my_indio_dev = indiodev_setup();
    if (IS_ERR(my_indio_dev))
        return PTR_ERR(data->acc_indio_dev);
    [...]
}
\end{mycode}

\begin{marker}
关于错误处理补充一点,摘录自内核编码风格部分:如果函数名称是动作或命令式命令,则函数返回的错误代码应该是整数;如果函数名称是一个谓词,则该函数应返回布尔值succeeded(成功的)。例如,add
work是一个命令,add\_work()函数返回0表示成功,返回-EBUSY表示失败。同样,PCI device present是谓词,pci\_dev\_present()函数如果成功找到匹配设备,则返回1;否则返回0。
\end{marker}

\subsection{消息打印——printk()}

printk()是在内核空间使用的,其作用和在用户空间使用printf()一样,执行dmesg命令可以显示printk()写入的行。根据所打印消息的重要性不同,可以选用include/linux/kern\_levels.h中定义的八个级别的日志消息,下面将介绍它们的含义。

下面列出的是内核日志级别,每个级别对应一个字符串格式的数字,其优先级与该数字的值成反比。例如,0具有较高的优先级:

\begin{mycode}{日志级别}
#define KERN_SOH                "\001"          /* ASCII头开始 */
#define KERN_SOH_ASCII          '\001'
#define KERN_EMERG              KERN_SOH "0"    /* 系统不可用 */
#define KERN_ALERT              KERN_SOH "1"    /* 必须立即采取行动 */
#define KERN_CRIT               KERN_SOH "2"    /* 重要条件 */
#define KERN_ERR                KERN_SOH "3"    /* 错误条件 */
#define KERN_WARNING            KERN_SOH "4"    /* 警报条件 */
#define KERN_NOTICE             KERN_SOH "5"    /* 正常但重要的情况 */
#define KERN_INFO               KERN_SOH "6"    /* 信息 */
#define KERN_DEBUG              KERN_SOH "7"    /* 调试级别的信息 */
\end{mycode}

以下代码显示如何打印内核消息和日志级别:

\begin{mycode}{example}
    printk(KERN_ERR "This is an error\n");
\end{mycode}

如果省略调试级别(\Colorbox{lightgrey}{\lstinline{printk("This is an error\n")}}),则内核将根据CONFIG\_DEFAULT\_MESSAGE\_LOGLEVEL配置选项(这是默认的内核日志级别)向该函数提供一个调试级别。实际上可以使用以下宏,其名称更有意义,它们是对前面所定义内容的包装——pr\_emerg、pr\_alert、pr\_crit、pr\_err、pr\_warning、pr\_notice、pr\_info和pr\_debug:

\begin{mycode}{example}
    pr_err("This is the same error\n");
\end{mycode}

对于新开发的驱动程序,建议使用这些包装。printk()的实现是这样的:调用它时,内核会将消息日志级别与当前控制台的日志级别进行比较;如果前者比后者更高(值更低),则消息会立即打印到控制台。可以这样检查日志级别参数:

\begin{mycode}{检查日志级别}
    cat /proc/sys/kernel/printk
    4 4 1 7
\end{mycode}

上面的输出中,第一个值是当前日志级别(4),第二个值是按照CONFIG\_DEFAULT\_MESSAGE\_LOGLEVEL选项设置的默认值。其他值与本章内容无关,可以忽略。

内核日志级别列表如下:

\chapter{一个完整的最简单的驱动Demo}

本章描述了基于全志V3S开发板的简单驱动程序和测试应用程序的设计流程。我们设计的驱动程序和测试程序极其简单，适合初学者上手学习。

软件运行的硬件环境是基于V3S开发板中的全志V3S处理器，该处理器集成了一个1.2GHz工作主频的单ARM CortexTM-A7 核，芯片内部集成了64MB DRAM 存储器。

设计流程概述

\begin{enumerate}
    \item 步骤一：编写一个\Colorbox{lightgrey}{\lstinline{demo_driver.c}}的驱动程序。
    \item 步骤二：编写makefile文件。
    \item 步骤三：编写一个\Colorbox{lightgrey}{\lstinline{demo_app.c}}的应用程序。
    \item 步骤四：在V3S开发板中安装\Colorbox{lightgrey}{\lstinline{demo_driver}}驱动程序，并测试\Colorbox{lightgrey}{\lstinline{demo_app}}应用程序。
\end{enumerate}

linux系统是一个分层结构，我们设计的\Colorbox{lightgrey}{\lstinline{demo_driver}}位于内核中的驱动部分，\Colorbox{lightgrey}{\lstinline{demo_app}}位于用户级。

\section{编写驱动程序}

编写一个\Colorbox{lightgrey}{\lstinline{demo_driver.c}}的驱动程序，驱动程序源码如下：

\begin{mycode}{demo\_driver.c}
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/init.h>

#define    DRIVER_MAJOR     188
#define    DEVICE_NAME     "demo_driver"

static int demo_open(struct inode *inode, struct file *file)
{    
    printk(KERN_EMERG "open\n");
    return 0;
}

static ssize_t demo_write(struct file *file, const char __user * buf, size_t count, loff_t *ppos)
{
    printk(KERN_EMERG "write\n");
    return 0;
}
static ssize_t demo_read(struct file *file,  char __user * buf, size_t count, loff_t *ppos)
{
    printk(KERN_EMERG "read\n");  
    return 0;
}

static int demo_close(struct inode *inode, struct file *file)
{
    printk(KERN_EMERG "close\n");
    return 0;
}

static struct file_operations demo_flops = 
{
    .owner  =   THIS_MODULE,
    .open   =   demo_open,     
    .write  =   demo_write,
    .read     =      demo_read,
    .release =  demo_close,
};

static int __init demo_init(void)
{
    int ret;
         
    //注册设备
    ret = register_chrdev(DRIVER_MAJOR,DEVICE_NAME, &demo_flops);

    if (ret < 0) 
    {
      printk(KERN_EMERG DEVICE_NAME " can't register major number.\n");
      return ret;
    }
    else
    {
        printk(KERN_EMERG DEVICE_NAME "demo init\n");
    }

    return 0;
}

static void __exit demo_exit(void)
{
    unregister_chrdev(DRIVER_MAJOR, DEVICE_NAME);
    printk(KERN_EMERG DEVICE_NAME "demo exit\n");
}

module_init(demo_init);
module_exit(demo_exit);
MODULE_LICENSE("GPL");
\end{mycode}

编译驱动程序依赖linux内核源码环境，需要把驱动C文件放在linux源码目录中，通过编译linux内核的方式得到驱动ko文件。

为了得到驱动ko，我们在linux/drivers/char目录下面创建一个demo\_driver的文件夹。

然后把demo\_driver.c程序拷贝到demo\_driver的文件夹中。

\section{编写Makefile}

我们通过编译linux内核的方式得到驱动ko文件，为了在编译内核时得到相应的驱动，我们需要在linux内核代码中增加和修改Makefile文件（Makefile的作用指定了工程编译的方法和步骤）。

首先我们修改linux/drivers/char目录下Makefile文件，在Makefile文件内容最末行加入一行代码：

\begin{mycode}{添加一行代码}
obj += demo_driver/
\end{mycode}

这句代码的意思是：编译内核时，子目录demo\_driver/下的文件也将进行编译。

我们在linux/drivers/char/demo\_driver中创建一个Makefile文件，同时在Makefile文件中加入一行代码：

\begin{mycode}{Makefile}
obj-m += demo_driver.o
\end{mycode}

这句代码的意思是：编译当前目录中的demo\_driver.c文件，输出一个demo\_driver.ko的驱动文件。

准备好demo\_driver.c文件和Makefile文件后，我们执行编译内核指令。

经过上述一波操作，我们得到了demo\_driver.ko的驱动文件。

\section{编写应用程序}

编写一个demo\_app.c的应用程序，程序源码如下：

\begin{mycode}{demo\_app.c}
#include <stdio.h> 
#include <string.h> 
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h> 
#include <fcntl.h> 
#include <unistd.h>

int main(int arvc, char *argv[])
{
    int fd;
    int value = 0;
    printf("demo test\n");

    /// 打开驱动
    fd = open("/dev/demo_driver", O_RDWR);

    while(1)
    {
        /// 执行驱动读操作
        read(fd, &value, 4);
        sleep(1);
        /// 执行驱动写操作
        write(fd, &value, 4);
        sleep(1);    
        
        printf("demo run\n");
    }
    return 0;
}
\end{mycode}

然后编译应用程序。

\begin{mycode}{shell}
arm-linux-gnueabihf-gcc -static -o demo_app demo_app.c
\end{mycode}

于是我们得到一个demo\_app可执行文件。

然后将得到的两个二进制\Colorbox{lightgrey}{\lstinline{demo_driver.ko}}和\Colorbox{lightgrey}{\lstinline{demo_app}}拷贝到我们的嵌入式系统里面。

安装驱动：

\begin{mycode}{安装驱动}
    $ insmod demo_driver.ko
    # 执行创建文件节点指令
    $ mknod /dev/demo_driver c 188 0
    # 查看驱动设备
    $ ls /dev
\end{mycode}

188的是设备号，我们在设计的驱动C文件中有如下定义：

\begin{mycode}{设备号定义}
#define    DRIVER_MAJOR     188
#define    DEVICE_NAME      "demo_driver"
\end{mycode}

执行\Colorbox{lightgrey}{\lstinline{demo_app}}程序：

\begin{mycode}{执行程序}
$ chmod 777 demo_app
$ ./demo_app
\end{mycode}

\begin{marker}
    如果重启设备，则需要重新加载驱动。
\end{marker}

\chapter{内核工具和辅助函数}

内核是独立的软件,正如将在本章中看到的那样,它没有使用任何C语言库。它实现了现代库中可能具有的所有机制(甚至更多),如压缩、字符串函数等。

本章涉及以下主题。

\begin{itemize}
    \item 介绍内核容器数据结构。
    \item 探讨内核睡眠机制。
    \item 使用定时器。
    \item 深入研究内核锁定机制(互斥锁、自旋锁)。
    \item 使用内核专用API实现延迟工作。
    \item 使用IRQ。
\end{itemize}

\section{理解宏container\_of}

在代码中管理多个数据结构时,几乎总是需要将一个结构嵌入另一个结构中,并随时检索它们,而不关心有关内存偏移或边界的问题。假设有一个struct person,其定义如下:

\begin{mycode}{struct person}
struct person {
    int age;
    char *name;
} p;
\end{mycode}

只用age或name上的指针就可以检索包装(包含)该指针的整个结构。顾名思义,container\_of宏用于查找指定结构字段的容器。该宏在include/linux/kernel.h中定义,如下所示:

\begin{mycode}{container\_of}
#define container_of(ptr, type, member) ({                  \
    const typeof(((type *)0)->member) * __mptr = (ptr);     \
    (type *)((char *)__mptr - offsetof(type, member)); })
\end{mycode}

不要害怕指针,就当它是:

\begin{mycode}{函数表达}
    container_of(pointer, container_type, container_field);
\end{mycode}

前面代码片段中包含的元素如下。

\begin{itemize}
    \item pointer:指向结构字段的指针。
    \item container\_type:包装(包含)指针的结构类型。
    \item container\_field:pointer指向的结构内字段的名称。
\end{itemize}

来看下面的容器:

\begin{mycode}{容器}
struct person {
    int age;
    char *name;
};
\end{mycode}

现在考虑其一个实例,以及一个指向其name成员的指针:

\begin{mycode}{example}
struct person somebody;
[...]
char *the_name_ptr = somebody.name;
\end{mycode}

除指向name成员的指针(the\_name\_ptr)外,还可以使用container\_of宏来获取指向包装此成员的整个结构(容器)的指针,方法如下:

\begin{mycode}{example}
struct person *the_person;
the_person = container_of(the_name_ptr, struct person, name);
\end{mycode}

container\_of考虑name从该结构开始处的偏移量,进而获得正确的指针位置。从指针the\_name\_ptr中减去字段name的偏移量,即可得到正确的位置。这就是该宏最后一行代码的功能:

\begin{mycode}{example}
(type *)( (char *)__mptr - offsetof(type,member) );
\end{mycode}

下面的例子实际应用该宏:

\begin{mycode}{example}
struct family {
    struct person *father;
    struct person *mother;
    int number_of_suns;
    int salary;
} f;

/*
* 指向结构字段的指针
* (可以是任何家庭的任何成员吗)
*/
struct *person = family.father;
struct family *fam_ptr;

/* 找回他的家族 */
fam_ptr = container_of(person, struct family, father);
\end{mycode}

关于container\_of宏,只需了解这些就够了。本书将进一步开发的真正驱动程序像下面这样:

\begin{mycode}{example}
struct mcp23016 {
    struct i2c_client *client;
    struct gpio_chip chip;
}

/* 检索给定指针chip字段的mcp23016结构体 */
static inline struct mcp23016 *to_mcp23016(struct gpio_chip *gc)
{
    return container_of(gc, struct mcp23016, chip);
}

static int mcp23016_probe(struct i2c_client *client, const struct i2c_device_id *id)
{
    struct mcp23016 *mcp;
    [...]
    mcp = devm_kzalloc(&client->dev, sizeof(*mcp), GFP_KERNEL);
    if (!mcp)
        return -ENOMEM;
    [...]
}
\end{mycode}

宏container\_of主要用在内核的通用容器中。在本书的一些例子(从第5章开始)中,会用到container\_of宏。

\section{链表}

想象一下,有一个驱动程序管理多个设备,假设有5个设备,可能需要在驱动程序中跟踪每个设备,这就需要链表。链表实际上有两种类型。

\begin{itemize}
    \item 单链表
    \item 双链表
\end{itemize}

内核开发者只实现了循环双链表,因为这个结构能够实现FIFO和LIFO,并且内核开发者要保持最少代码。

为了支持链表,代码中要添加的头文件是<linux/list.h>。内核中链表实现核心部分的数据结构是struct list\_head,其定义如下:

\begin{mycode}{链表定义}
struct list_head {
    struct list_head *next, *prev;
};
\end{mycode}

struct list\_head用在链表头和每个节点中。在内核中,将数据结构表示为链表之前,该结构必须嵌入struct list\_head字段。例如,我们来创建汽车链表:

\begin{mycode}{汽车链表}
struct car {
    int door_number;
    char *color;
    char *model;
};
\end{mycode}

在创建汽车链表之前,必须修改其结构,嵌入struct list\_head字段。结构变成如下形式:

\begin{mycode}{example}
struct car {
    int door_number;
    char *color;
    char *model;
    struct list_head list; /* 内核的链表结构 */
};
\end{mycode}

创建struct list\_head变量,该变量总是指向链表的头部(第一个元素)。list\_head的这个实例与任何汽车都无关,而是一个特殊实例:

\begin{mycode}{特殊实例}
    static LIST_HEAD(carlist);
\end{mycode}

现在可以创建汽车并将其添加到链表carlist:

\begin{mycode}{example}
#include <linux/list.h>
struct car *redcar = kmalloc(sizeof(*car), GFP_KERNEL);
struct car *bluecar = kmalloc(sizeof(*car), GFP_KERNEL);

/* 初始化每个节点的列表条目*/
INIT_LIST_HEAD(&bluecar->list);
INIT_LIST_HEAD(&redcar->list);

/* 为颜色和模型字段分配内存,并填充每个字段 */
[...]
list_add(&redcar->list, &carlist) ;
list_add(&bluecar->list, &carlist) ;
\end{mycode}

现在,carlist包含两个元素。接下来深入介绍链表API。

\subsection{创建和初始化链表}

有两种方法创建和初始化链表。

1. 动态方法

动态方法由struct list\_head组成,用INIT\_LIST\_HEAD宏初始化:

\begin{mycode}{动态初始化链表}
struct list_head mylist;
INIT_LIST_HEAD(&mylist);
\end{mycode}

以下是INIT\_LIST\_HEAD的展开形式:

\begin{mycode}{example}
static inline void INIT_LIST_HEAD(struct list_head *list)
{
    list->next = list;
    list->prev = list;
}
\end{mycode}

2. 静态方法

静态分配通过LIST\_HEAD宏完成:

\begin{mycode}{example}
LIST_HEAD(mylist)
\end{mycode}

LIST\_HEAD的定义如下:

\begin{mycode}{example}
#define LIST_HEAD(name) \
    struct list_head name = LIST_HEAD_INIT(name)
\end{mycode}

其展开如下:

\begin{mycode}{example}
#define LIST_HEAD_INIT(name) { &(name), &(name) }
\end{mycode}

这为name字段内的每个指针(prev和next)赋值,使其指向name自身(就像INIT\_LIST\_HEAD做的那样)。

\subsection{创建链表节点}

要创建新节点,只需创建数据结构实例,初始化嵌入在其中的list\_head字段。以汽车为例,其代码如下:

\begin{mycode}{example}
struct car *blackcar = kzalloc(sizeof(struct car), GFP_KERNEL);

/* 非静态初始化,因为它是嵌入的列表字段 */
INIT_LIST_HEAD(&blackcar->list);
\end{mycode}

如前所述,使用的INIT\_LIST\_HEAD是动态分配的链表,它通常是另一个结构的一部分。

\subsection{添加链表节点}

内核提供的list\_add用于向链表添加新项,它是内部函数\_\_list\_add的包装:

\begin{mycode}{example}
void list_add(struct list_head *new, struct list_head *head);
static inline void list_add(struct list_head *new, struct list_head *head)
{
    __list_add(new, head, head->next);
}
\end{mycode}

\_\_list\_add将两个已知项作为参数,在它们之间插入元素。它在内核中的实现非常简单:

\begin{mycode}{example}
static inline void __list_add(struct list_head *new, struct list_head *prev, struct list_head *next)
{
    next->prev = new;
    new->next = next;
    new->prev = prev;
    prev->next = new;
}
\end{mycode}

下面的例子在链表中添加两辆车:

\begin{mycode}{添加两辆车}
list_add(&redcar->list, &carlist);
list_add(&blue->list, &carlist);
\end{mycode}

这种模式可以用来实现堆栈。将节点添加到链表的另一个函数,代码如下:

\begin{mycode}{example}
void list_add_tail(struct list_head *new, struct list_head *head);
\end{mycode}

这将把指定新项插入链表的末尾。对于之前的例子,可以使用以下代码:

\begin{mycode}{example}
list_add_tail(&redcar->list, &carlist);
list_add_tail(&blue->list, &carlist);
\end{mycode}

这种模式可以用来实现队列。

\subsection{删除链表节点}

内核代码中的链表处理是一项简单的任务。删除节点很简单:

\begin{mycode}{删除节点}
void list_del(struct list_head *entry);
\end{mycode}

删除红色车

\begin{mycode}{删除红色车}
list_del(&redcar->list);
\end{mycode}

\begin{marker}
list\_del断开指定节点的prev和next指针,移除该节点。分配给该节点的内存需要使用kfree手动释放。
\end{marker}

\subsection{链表遍历}

使用宏\Colorbox{lightgrey}{\lstinline{list_for_each_entry(pos, head, member)}}进行链表遍历。

\begin{itemize}
\item head:链表的头节点。
\item member:数据结构(在我们的例子中,它是list)中链表struct list\_head的名称。
\item pos:用于迭代。它是一个循环游标,就像for(i=0; i<foo; i++)中的i。head可以是链表的头节点或任一项,这没关系,因为所处理的是双向链表:
\begin{mycode}{example}
struct car *acar; /* loop counter */
int blue_car_num = 0;
/* 'list' is the name of the list_head struct in our data structure */
list_for_each_entry(acar, carlist, list) {
    if(acar->color == "blue")
        blue_car_num++;
}
\end{mycode}
\end{itemize}

为什么需要数据结构中list\_head类型字段的名称?请看list\_for\_each\_entry:

\begin{mycode}{example}
#define list_for_each_entry(pos, head, member)                  \
for (pos = list_entry((head)->next, typeof(*pos), member);      \
    &pos->member != (head);                                     \
    pos = list_entry(pos->member.next, typeof(*pos), member))

#define list_entry(ptr, type, member)                           \
    container_of(ptr, type, member)
\end{mycode}

鉴于此,我们可以理解这都是container\_of的功能。另外,还请记住list\_for\_each\_entry\_safe(pos, n, head, member)。

\chapter{设备树的概念}

设备树（DT，Derive Tree）是易于阅读的硬件描述文件，它采用JSON式的格式化风格，在这种简单的树形结构中，设备表示为带有属性的节点。属性可以是空（只有键，用来描述布尔值），也可以是键值对，其中的值可以包含任意的字节流。本章简单地介绍DT，每个内核子系统或框架都有自己的DT绑定。讲解有关话题时将包括具体的绑定。DT源于OF，这是计算机公司公认的标准，其主要目的是定义计算机固件系统的接口。

本章涉及以下主题。

\begin{itemize}
\item 命名约定，以及别名和标签。
\item 描述数据类型及其API。
\item 管理寻址方案和访问设备资源。
\item 实现OF匹配风格，提供应用程序的相关数据。
\end{itemize}

\section{设备树机制}

将选项\Colorbox{lightgrey}{\lstinline{CONFIG_OF}}设置为Y即可在内核中启用DT。要在驱动程序中调用DT API，必须添加以下头文件：

\begin{mycode}{头文件}
#include <linux/of.h>
#include <linux/of_device.h>
\end{mycode}

DT支持一些数据类型。下面通过对实例节点的描述来介绍这些数据类型：

\begin{mycode}{数据类型}
/* 注释 */
/* 另一个注释 */
node_label: nodename@reg{
    string-property = "a string";
    string-list = "red fish", "blue fish";
    one-int-property = <197>; /* 该属性中的一个单元格*/
    /* 每个数字（单元格）是一个 32 位的整型（uint32）
     * 属性中有 3 个单元格
     */
    int-list-property = <0xbeef 123 0xabcd4>;
    mixed-list-property = "a string", <0xadbcd45>, <35>, [0x01 0x23 0x45]
    byte-array-property = [0x01 0x23 0x45 0x67];
    boolean-property;
};
\end{mycode}

以下是设备树中使用的一些数据类型的定义。

\begin{itemize}
\item 文本字符串用双引号表示。可以使用逗号来创建字符串列表。
\item 单元格是由尖括号分隔的32位无符号整数。
\item 布尔数据不过是空属性。其取值是true或false取决于属性存在与否。
\end{itemize}

\subsection{命名约定}

每个节点都必须有\Colorbox{lightgrey}{\lstinline{<name> [@ <address>]}}形式的名称，其中\Colorbox{lightgrey}{\lstinline{<name>}}是一个字符串，其长度最多为31个字符，\Colorbox{lightgrey}{\lstinline{[@ <address>]}}是可选的，具体取决于节点代表是否为可寻址的设备。\Colorbox{lightgrey}{\lstinline{<address>}}是用来访问设备的主要地址。设备命名的一个例子如下：

\begin{mycode}{例子}
expander@20 {
    compatible = "microchip,mcp23017";
    reg = <20>;
    [...]
};
\end{mycode}

或者

\begin{mycode}{例子}
i2c@021a0000 {
    compatible = "fsl,imx6q-i2c", "fsl,imx21-i2c";
    reg = <0x021a0000 0x4000>;
    [...]
};
\end{mycode}

另外,仅当打算从另一节点的属性引用节点时,标记节点才有用。在6.1.2节将看到标签是指向节点的指针。

\subsection{别名、标签和phandle}

了解这3个要素的工作机制非常重要,它们经常在DT中使用。下面的DT例子解释它们是如何工作的:

\begin{mycode}{三要素}
aliases {
    ethernet0 = &fec;
    gpio0 = &gpio1;
    gpio1 = &gpio2;
    mmc0 = &usdhc1;
    [...]
};
gpio1: gpio@0209c000 {
    compatible = "fsl,imx6q-gpio", "fsl,imx35-gpio";
    [...]
};
node_label: nodename@reg {
    [...];
    gpios = <&gpio1 7 GPIO_ACTIVE_HIGH>;
};
\end{mycode}

标签不过是标记节点的方法,可以用唯一的名称来标识节点。在现实世界中,DT编译器将该名称转换为唯一的32位值。在前面的例子中,gpio1和node\_label都是标签。之后可以用标签来引用节点,因为标签对于节点是唯一的。

指针句柄(pointer handle,简写为phandle)是与节点相关联的32位值,用于唯一标识该节点,以便可以从另一个节点的属性引用该节点。标签用于一个指向节点的指针。使用\Colorbox{lightgrey}{\lstinline{<&mylabel>}}可以指向标签为mylabel的节点。

\begin{marker}
    \&的用途就像在C编程语言中一样,用于获取元素的地址。
\end{marker}

在前面的例子中,\Colorbox{lightgrey}{\lstinline{&gpio1}}被转换为phandle,以便引用gpio1节点。下面的例子也是这样:

\begin{mycode}
thename@address {
    property = <&mylabel>;
};

mylabel: thename@adresss {
    [...]
}
\end{mycode}

为了在查找节点时不遍历整棵树,引入了别名的概念。在DT中,别名节点可以看作是快速查找表,即另一个节点的索引。可以使用函数\Colorbox{lightgrey}{\lstinline{find_node_by_alias()}}来查找指定别名的节点。别名不是直接在DT源中使用,而是由Linux内核来引用。

\subsection{DT编译器}

DT有两种形式:文本形式(代表源,也称作DTS)和二进制块形式(代表编译后的DT),也称作DTB。源文件的扩展名是.dts。实际上,还有.dtsi文本文件,代表SoC级定义,而.dts文件代表开发板定义。就像在源文件(.c)中包含头文件(.h)一样,应该把.dtsi作为头文件包含在.dts文件中。而二进制文件则使用.dtb扩展名。

实际上还有第三种形式,即DT在\Colorbox{lightgrey}{\lstinline{/proc/device-tree}}中的运行时表示。

正如其名称所述,用于编译设备树的工具称为设备树编译器(dtc)。从根内核源代码,可以为特定的体系结构编译独立的特定DT或所有DT。

下面为ARM SoC编译所有DT(.dts)文件:

\begin{mycode}{编译设备树}
ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- make dtbs
\end{mycode}

编译单独的DT:

\begin{mycode}{编译单独的设备树文件}
ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- make imx6dl-sabrelite.dtb
\end{mycode}

在上一个例子中,源文件的名称是imx6dl-sabrelite.dts。

对于编译过的设备树(.dtb)文件,可以做相反的操作,从中提取源(.dts)文件:

\begin{mycode}{反编译设备树文件}
dtc -I dtb -O dtsarch/arm/boot/dts imx6dl-sabrelite.dtb > path/to/my_devicetree.dts
\end{mycode}

\begin{marker}
为了调试,将DT公开给用户空间可能是有用的。使用CONFIG\_PROC\_DEVICETREE配置变量可以实现该目的。然后,可以浏览/proc/device-tree中的DT。
\end{marker}

\section{表示和寻址设备}

每个设备在DT中至少有一个节点。某些属性对于许多设备类型是通用的,特别是位于内核已知总线(SPI、I2C、平台、MDIO等)上的设备。这些属性是reg、\#address-cells和\#size-cells,它们的用途是在其所在总线上进行设备寻址。也就是说,主要的寻址属性是reg,这是一个通用属性,其含义取决于设备所在的总线。size-cell和address-cell的前缀\#(sharp)可以翻译为length。

每个可寻址设备都具有reg属性,该属性是reg = <address0 size0 [address1 size1] [address2 size2] ...>形式的元组列表,其中每个元组代表设备使用的地址范围。\#size-cells(长度单元)指示使用多少个32位单元来表示大小,如果与大小无关,则可以是0。而\#address-cells(地址单元)指示用多少个32位单元来表示地址。换句话说,每个元组的地址元素根据\#address-cell来解释;长度元素也是如此,它根据\#size-cell进行解释。

实际上,可寻址设备继承自它们父节点的\#size-cell和\#address-cell,父节点代表总线控制器。指定设备中存在\#size-cell和\#address-cell不会影响设备本身,但影响其子设备。换句话说,在解释给定节点的reg属性之前,必须知道父节点\#address-cells和\#size-cells的值。父节点可以自由定义适用于设备子节点(孩子)的寻址方案。

\subsection{SPI和\texorpdfstring{$I^2C$寻址}{I2C寻址}}

SPI和$I^2C$设备都属于非内存映射设备,因为它们的地址对CPU不可访问。而父设备的驱动程序(总线控制器驱动程序)将代表CPU执行间接访问。每个$I^2C$/SPI设备都表示为设备所在$I^2C$/SPI总线节点的子节点。对于非存储器映射的设备,\#size-cells属性为0,寻址元组中的size元素为空。这意味着这种设备的reg属性总是只有一个单元:

\begin{mycode}{例子}
&i2c3 {
    [...]
    status = "okay";

    temperature-sensor@49 {
        compatible = "national,lm73";
        reg = <0x49>;
    };

    pcf8523: rtc@68 {
        compatible = "nxp,pcf8523";
        reg = <0x68>;
    };
};

&ecspi1 {
    fsl,spi-num-chipselects = <3>;
    cs-gpios = <&gpio5 17 0>, <&gpio5 17 0>, <&gpio5 17 0>;
    status = "okay";
    [...]

    ad7606r8_0: ad7606r8@1 {
        compatible = "ad7606-8";
        reg = <1>;
        spi-max-frequency = <1000000>;
        interrupt-parent = <&gpio4>;
        interrupts = <30 0x0>;
        convst-gpio = <&gpio6 18 0>;
    };
};
\end{mycode}

查看arch/arm/boot/dts/imx6qdl.dtsi中的SoC级文件就会发现:在i2c和spi节点中,\#size-cells和\#address-cells分别设置为0(前者)和1(后者),它们分别是前面所列I2C和SPI设备的父节点。这有助于理解它们的reg属性,reg属性只是一个保存地址值的单元格。

$I^2C$设备的reg属性用于指定总线上设备的地址。对于SPI设备,reg表示从控制器节点所具有的芯片选择列表中分配给设备的芯片选择线的索引。例如,对于ad7606r8 ADC,芯片选择线索引是1,对应于cs-gpios中的<\&gpio5 17 0>,cs-gpios是控制器节点的芯片选择列表。

为什么使用$I^2C$/SPI节点的phandle:因为$I^2C$/SPI设备应在开发板文件(.dts)中声明,而I2C/SPI总线控制器在SoC级文件(.dtsi)中声明。

\subsection{平台设备寻址}

本节介绍简单的内存映射设备,其内存可由CPU访问。在这里,reg属性仍然定义设备的地址,这是可以访问设备的内存区域列表。每个区域用单元格元组表示,其中第一个单元格是内存区域的基地址,第二个元组是该区域的大小。它具有的形式是reg = <base0 length0 [base1 length1] [address2 length2] ...>。每个元组代表设备使用的地址范围。

在现实世界中,人们应该在知道其他两个属性(\#size-cells和\#address-cells)值的情况下解释reg属性。\#size-cells指出在每个子reg元组中长度字段有多大。\#address-cell也一样,它说明指定一个地址必须使用多少个单元。

这种设备应该在具有特殊值compatible = "simple-bus"的节点内声明,这意味着简单的内存映射总线,没有特定的处理和驱动程序:

\begin{mycode}{例子}
soc {
    #address-cells = <1>;
    #size-cells = <1>;
    compatible = "simple-bus";
    aips-bus@02000000 { /* AIPS1 */
        compatible = "fsl,aips-bus", "simple-bus";
        #address-cells = <1>;
        #size-cells = <1>;
        reg = <0x02000000 0x100000>;
        [...];

        spba-bus@02000000 {
            compatible = "fsl,spba-bus", "simple-bus";
            #address-cells = <1>;
            #size-cells = <1>;
            reg = <0x02000000 0x40000>;
            [...]
            ecspi1: ecspi@02008000 {
                #address-cells = <1>;
                #size-cells = <0>;
                compatible = "fsl,imx6q-ecspi", "fsl,imx51-ecspi";
                reg = <0x02008000 0x4000>;
                [...]
            };
            i2c1: i2c@021a0000 {
                #address-cells = <1>;
                #size-cells = <0>;
                compatible = "fsl,imx6q-i2c", "fsl,imx21-i2c";
                reg = <0x021a0000 0x4000>;
                [...]
            };
        };
    };
\end{mycode}

在前面的示例中,父节点compatible的属性值为simple-bus,其子节点将被注册为平台设备。设置\#size-cells = <0>也能够看到I2C和SPI总线控制器怎样改变其子节点的寻址方式,因为这与它们无关。从内核设备树文档可以查找所有绑定信息:Documentation/devicetree/bindings/。

\section{处理资源}

驱动程序的主要目的是处理和管理设备,并且大部分时间将其功能展现给用户空间。这里的目标是收集设备的配置参数,特别是资源(存储区、中断线、DMA通道、时钟等)。

以下是本节中将要使用的设备节点。它是在arch/arm/boot/dts/imx6qdl.dtsi中定义的i.MX6 UART设备节点:

\begin{mycode}{uart}
uart1: serial@02020000 {
    compatible = "fsl,imx6q-uart","fsl,imx21-uart";
    reg = <0x02020000 0x4000>;
    interrupts = <0 26 IRQ_TYPE_LEVEL_HIGH>;
    clocks = <&clks IMX6QDL_CLK_UART_IPG>,<&clks IMX6QDL_CLK_UART_SERIAL>;
    clock-names = "ipg", "per";
    dmas = <&sdma 25 4 0>, <&sdma 26 4 0>;
    dma-names = "rx", "tx";
    status = "disabled";
};
\end{mycode}

\subsection{命名资源的概念}

当驱动程序期望某种类型的资源列表时,由于编写开发板设备树的人通常不是写驱动程序的人,因此不能保证该列表是以驱动程序期望的方式排序。例如,驱动程序可能期望其设备节点具有2条IRQ线路,一条用于索引0处的Tx事件,另一条用于索引1处的Rx。如果这种顺序得不到满足会发生什么情况?驱动就会发生异常行为。为了避免这种不匹配,引入了命名资源(clock、irq、dma、reg)的概念。它由定义资源列表和命名组成,因此无论索引是什么,给定的名称总将与资源相匹配。

命名资源的相应属性如下。

\begin{itemize}
    \item reg-names:reg属性中的内存区域列表。
    \item clock-names:clocks属性中命名clocks。
    \item interrupt-names:为interrupts属性中的每个中断指定一个名称。
    \item dma-names:用于dma属性。
\end{itemize}

现在,创建一个假的设备节点以解释上述概念:

\begin{mycode}{例子}
fake_device {
    compatible = "packt,fake-device";
    reg = <0x02020000 0x4000>, <0x4a064800 0x200>, <0x4a064c00 0x200>;
    reg-names = "config", "ohci", "ehci";
    interrupts = <0 66 IRQ_TYPE_LEVEL_HIGH>, <0 67 IRQ_TYPE_LEVEL_HIGH>;
    interrupt-names = "ohci", "ehci";
    clocks = <&clks IMX6QDL_CLK_UART_IPG>, <&clks IMX6QDL_CLK_UART_SERIAL>;
    clock-names = "ipg", "per";
    dmas = <&sdma 25 4 0>, <&sdma 26 4 0>;
    dma-names = "rx", "tx";
};
\end{mycode}

驱动程序中提取每个命名资源的代码如下所示:

\begin{mycode}{提取命名资源}
struct resource *res1, *res2;
res1 = platform_get_resource_byname(pdev, IORESOURCE_MEM, "ohci");
res2 = platform_get_resource_byname(pdev, IORESOURCE_MEM, "config");
struct dma_chan *dma_chan_rx, *dma_chan_tx;
dma_chan_rx = dma_request_slave_channel(&pdev->dev, "rx");
dma_chan_tx = dma_request_slave_channel(&pdev->dev, "tx");
int txirq, rxirq;
txirq = platform_get_irq_byname(pdev, "ohci");
rxirq = platform_get_irq_byname(pdev, "ehci");
structclk *clck_per, *clk_ipg;
clk_ipg = devm_clk_get(&pdev->dev, "ipg");
clk_ipg = devm_clk_get(&pdev->dev, "pre");
\end{mycode}

这样,就可以确保把正确的名字映射到正确的资源上,而不用再使用索引了。

\subsection{访问寄存器}

在这里,驱动程序将占用内存区域,并将其映射到虚拟地址空间。第11章将进一步讨论这个问题。

\begin{mycode}{例子}
struct resource *res;
void __iomem *base;
res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
/*
* 这里使用request_mem_region(res->start,
resource_size(res), pdev->name)
* 和ioremap(iores->start, resource_size(iores)请
求和映射内存区域
*
* 这些功能在第11章中讨论
*/
base = devm_ioremap_resource(&pdev->dev, res);
if (IS_ERR(base))
    return PTR_ERR(base);
\end{mycode}

\Colorbox{lightgrey}{\lstinline{platform_get_resource()}}将根据第一个(索引0)reg赋值中提供的内存区域设置struct res的开始和结束字段。请记住\Colorbox{lightgrey}{\lstinline{platform_get_resource()}}的最后一个参数代表资源索引。在前面的示例中,0指定了该资源类型的第一个值,以防在DT节点中为设备分配多个存储区域。在这个例子中,reg = <0x02020000 0x4000>表示分配的区域从物理地址0x02020000开始,大小为0x4000字节。\Colorbox{lightgrey}{\lstinline{platform_get_resource()}}将设置res.start = 0x02020000和res.end = 0x02023fff。

\subsection{处理中断}

中断接口实际上分为两部分,消费者端和控制器端。DT中用4个属性描述中断连接。

控制器是为消费者提供中断线的设备。在控制器端有以下属性。

\begin{itemize}
\item interrupt-controller:为了将设备标记为中断控制器而应该定义的空(布尔)属性。
\item \#interrupt-cells:这是中断控制器的属性。它指出为该中断控制器指定一个中断要使用多少个单元。
\end{itemize}

消费者是生成中断的设备。消费者绑定需要以下属性。

\begin{itemize}
    \item interrupt-parent:对于产生中断的设备节点,这个属性包含指向设备所连接的中断控制器节点的指针phandle。如果省略,则设备从其父节点继承该属性。
    \item interrupts:它是中断说明符。
\end{itemize}

中断绑定和中断说明符与中断控制器设备相关联。通过\#interrupt-cells属性定义的中断输入单元数量取决于中断控制器,这是唯一的决定因素。对于i.MX6,中断控制器是全局中断控制器(Global Interrupt Controller,GIC)。在Documentation/devicetree/bindings/arm/gic.txt中很好地解释了其绑定。

1. 中断处理程序

这包括从DT获取IRQ号码,映射到Linux IRQ,再为其注册函数回调。执行此操作的驱动程序代码非常简单:

\begin{mycode}{example}
int irq = platform_get_irq(pdev, 0);
ret = request_irq(irq, imx_rxint, 0,
dev_name(&pdev->dev), sport);
\end{mycode}

platform\_get\_irq()调用将返回中断号,devm\_request\_irq()可以用这个中断号(之后IRQ在/proc/interrupts中是可见的)。

第二个参数0表示需要在设备节点中指定的第一个中断。如果有多个中断,则可以根据需要的中断更改这个索引,或者只使用命名的资源。在前面的例子中,设备节点包含中断说明符,像下面这样:

\begin{mycode}{example}
    interrupts = <0 66 IRQ_TYPE_LEVEL_HIGH>;
\end{mycode}

\begin{itemize}
    \item 根据ARM GIC,第一个单元说明中断类型。
    \item 0:共享外设中断(SPI),用于核间共享的中断信号,可由GIC路由至任意核。
    \item 1:专用外设中断(PPI),专用于单核的中断信号。
    \item 第二个单元格保存中断号。该中断号取决于中断线是PPI还是SPI。
    \item 第三个单元,这里的\Colorbox{lightgrey}{\lstinline{IRQ_TYPE_LEVEL_HIGH}}代表感知级别。所有可用的感知级别在include/linux/irq.h中定义。
\end{itemize}

2. 中断控制器代码

interrupt-controller属性用于将设备声明为中断控制器。\#interruptcells属性定义必须使用多少个单元格来定义单个中断线。

\section{平台驱动程序和DT}

平台驱动程序也使用DT。也就是说,这是现在推荐的处理平台设备的方法,不再需要使用开发板文件,甚至不需要在设备的属性更改时重新编译内核。可否记得,在第5章讨论了OF匹配样式,这是一种基于DT的匹配机制。下面介绍它的工作原理。

“OF匹配风格”是平台核心执行的第一种匹配机制,以匹配设备及其驱动程序。它使用设备树的compatible属性来匹配of\_match\_table中的设备项,设备项是struct driver子结构的一个字段。每个设备节点都有compatible属性,它是字符串或字符串列表。任何驱动程序只要声明compatible属性中列出的字符串之一,就将触发匹配,并看到其probe函数执行。

DT匹配项在内核中被描述为struct of\_device\_id结构的实例,该结构定义在linux/mod\_devicetable.h中,如下所示:

\begin{mycode}{example}
    // 我们只对结构的最后两个元素感兴趣
    struct of_device_id {
        [...]
        char compatible[128];
        const void *data;
    }
\end{mycode}

该结构中每个元素的含义如下。

\begin{itemize}
\item char compatible [128]:这是用来匹配DT中设备节点兼容属性的字符串。它们必须完全相同才算匹配。
\item const void * data:这可以指向任何结构,这个结构可以用作每个设备类型的配置数据。
\end{itemize}

由于of\_match\_table是指针,因此可以传递struct of\_device\_id数组,使驱动程序兼容多个设备:

\begin{mycode}{example}
static const struct of_device_id imx_uart_dt_ids[] = {
    { .compatible = "fsl,imx6q-uart", },
    { .compatible = "fsl,imx1-uart", },
    { .compatible = "fsl,imx21-uart", },
    { /* sentinel */ }
};
\end{mycode}

一旦在驱动程序的子结构中填充了ID数组,就必须把它传递到平台驱动程序的of\_match\_table字段:

\chapter{字符设备驱动程序}

本章的目的是编写一个完整的字符设备驱动。我们开发一个字符驱动是因为这一类适合大部分简单硬件设备。字符驱动也比块驱动易于理解（我们在后续章节接触）。我们的最终目的是编写一个模块化的字符驱动，但是我们不会在本章讨论模块化的事情。

贯串本章，我们展示从一个真实设备驱动提取的代码片段：scull（Simple Character Utility for Loading Localities）。scull是一个字符驱动，操作一块内存区域好像它是一个设备。在本章，因为 scull 的这个怪特性, 我们可互换地使用设备这个词和``scull使用的内存区''。

scull的优势在于它不依赖硬件。scull只是操作一些从内核分配的内存。任何人都可以编译和运行scull，并且scull在Linux运行的体系结构中可移植。另一方面，这个设备除了演示内核和字符驱动的接口和允许用户运行一些测试之外，不做任何有用的事情。

\section{scull的设计}

编写驱动的第一步是定义驱动将要提供给用户程序的能力（机制）。因为我们的``设备''是计算机内存的一部分，我们可自由做我们想做的事情。它可以是一个顺序的或者随机存取的设备，一个或多个设备，等等。

为使 scull 作为一个模板来编写真实设备的真实驱动，我们将展示给你如何在计算机内存上实现几个设备抽象，每个有不同的特点。

scull 源码实现下面的设备。模块实现的每种设备都被引用做一种类型。

\begin{itemize}
    \item $scull0 \sim scull3$：4 个设备，每个由一个全局永久的内存区组成。全局意味着如果设备被多次打开，设备中含有的数据由所有打开它的文件描述符共享。永久意味着如果设备关闭又重新打开，数据不会丢失。这个设备用起来有意思，因为它可以用惯常的命令来存取和测试，例如 cp，cat，以及 I/O 重定向。
    \item $scullpipe0 \sim scullpipe3$：4个FIFO（先入先出）设备，行为类似管道。一个进程读的内容来自另一个进程所写的。如果多个进程读同一个设备，它们竞争数据。scullpipe的内部将展示阻塞读写和非阻塞读写如何实现，而不必采取中断。尽管真实的驱动使用硬件中断来同步它们的设备，阻塞和非阻塞操作的主题是重要的并且与中断处理是分开的。
    \item scullsingle
    \item scullpriv
    \item sculluid
    \item scullwuid
    
这些设备与 scull0 相似，但是在什么时候允许打开上有一些限制。第一个（snullsingle）只允许一次一个进程使用驱动，而 scullpriv 对每个虚拟终端（或者 X 终端会话）是私有的，因为每个控制台/终端上的进程有不同的内存区。sculluid 和 scullwuid 可以多次打开，但是一次只能是一个用户；前者返回一个``设备忙''错误，如果另一个用户锁着设备，而后者实现阻塞打开。这些 scull 的变体可能看来混淆了策略和机制，但是它们值得看看，因为一些实际设备需要这类管理。
\end{itemize}

每个 scull 设备演示了驱动的不同特色，并且呈现了不同的难度。本章涉及 scull0 到 scull3 的内部结构。

\section{主设备号和次设备号}

字符设备通过文件系统中的名字来读写。那些名字称为文件系统的特殊文件，或者设备文件，或者文件系统的简单节点；惯例上它们位于 \Colorbox{lightgrey}{\lstinline{/dev}} 目录。字符驱动的特殊文件由使用 \Colorbox{lightgrey}{\lstinline{ls -l}} 的输出的第一列的``c''标识。块设备也出现在 \Colorbox{lightgrey}{\lstinline{/dev}} 中，但是它们由``b''标识。本章集中在字符设备，但是下面的很多信息也适用于块设备。

如果执行 \Colorbox{lightgrey}{\lstinline{ls -l}} 命令，你会看到在设备文件项中有 2 个数（由一个逗号分隔）在最后修改日期前面，这里通常是文件长度出现的地方。这些数字是给特殊设备的主次设备编号。下面的列表显示了一个典型系统上出现的几个设备。它们的主编号是 1, 4, 7, 和 10, 而次编号是 1, 3, 5, 64, 65, 和 129。

\begin{mycode}{列表}
crw-rw-rw- 1 root root 1,3   Apr 11 2002  null
crw------- 1 root root 10,1  Apr 11 2002  psaux
crw------- 1 root root 4,1   Oct 28 03:04 tty1
crw-rw-rw- 1 root tty  4,64  Apr 11 2002  ttys0
crw-rw---- 1 root uucp 4,65  Apr 11 2002  ttyS1
crw--w---- 1 vcsa tty  7,1   Apr 11 2002  vcs1
crw--w---- 1 vcsa tty  7,129 Apr 11 2002  vcsa1
crw-rw-rw- 1 root root 1,5   Apr 11 2002  zero
\end{mycode}

传统上, 主编号标识设备相连的驱动. 例如, /dev/null 和 /dev/zero 都由驱动 1 来管理，而虚拟控制台和串口终端都由驱动 4 管理；同样，vcs1 和 vcsa1 设备都由驱动 7 管理。现代 Linux 内核允许多个驱动共享主编号，但是你看到的大部分设备仍然按照一个主编号一个驱动的原则来组织。

次编号被内核用来决定引用哪个设备。依据你的驱动是如何编写的（如同我们下面见到的），你可以从内核得到一个你的设备的直接指针，或者可以自己使用次编号作为本地设备数组的索引。不论哪个方法，内核自己几乎不知道次编号的任何事情，除了它们指向你的驱动实现的设备。

\subsection{设备编号的内部表示}

在内核中，dev\_t 类型（在 <linux/types.h> 中定义）用来保存设备编号 —— 包括主设备号和次设备号。对于 2.6.0 内核，dev\_t 是 32 位的数值，其中 12 位用作主编号，其余的 20 位用作次编号。你的代码应当对于设备编号的组织从不做任何假设；相反，应当利用在 <linux/kdev\_t.h> 中的一套宏定义。为获得一个 dev\_t 的主或者次编号，使用：

\begin{mycode}{设备编号}
MAJOR(dev_t dev);
MINOR(dev_t dev);
\end{mycode}

相反，如果你有主次编号，需要将其转换为一个 dev\_t ，使用：

\begin{mycode}{转换成dev\_t}
MKDEV(int major, int minor);
\end{mycode}

\subsection{分配和释放设备编号}

在建立一个字符驱动时你的驱动需要做的第一件事是获取一个或多个设备编号来使用。为此目的的必要的函数是 \Colorbox{lightgrey}{\lstinline{register_chrdev_region}}，在 <linux/fs.h>中声明：

\begin{mycode}{获取设备号}
int register_chrdev_region(dev_t first, unsigned int count, char *name);
\end{mycode}

这里，first 是你要分配的起始设备编号。first 的次编号部分常常是 0，但是没有要求必须这样。count 是你请求的连续设备编号的总数。注意，如果 count 太大，你要求的范围可能溢出到下一个次编号；但是只要你要求的编号范围可用，一切都仍然会正确工作。最后，name 是应当连接到这个编号范围的设备的名字；它会出现在 /proc/devices 和 sysfs 中。

如同大部分内核函数，如果分配成功进行，\Colorbox{lightgrey}{\lstinline{register_chrdev_region}} 的返回值是 0 。出错的情况下，返回一个负的错误码，你不能读写请求的编号区域。

如果你确实事先知道你需要哪个设备编号，\Colorbox{lightgrey}{\lstinline{register_chrdev_region}} 工作会工作的很好。然而，你常常不会知道你的设备使用哪个主编号；在 Linux 内核开发社团中一直努力使用动态分配设备编号。 内核会乐于动态为你分配一个主编号，但是你必须使用一个不同的函数来请求这个分配。

\begin{mycode}{动态分配设备号}
int alloc_chrdev_region(dev_t *dev, unsigned int firstminor, unsigned int count, char *name);
\end{mycode}

使用这个函数，dev 是一个只输出的参数，它在函数成功完成时持有你的分配范围的第一个数。firstminor 应当是请求的第一个要用的次编号；它常常是 0 。count 和 name 参数如同给 \Colorbox{lightgrey}{\lstinline{request_chrdev_region}} 的一样。

不管你任何分配你的设备编号，你应当在不再使用它们时释放它。设备编号的释放使用：

\begin{mycode}{释放编号}
void unregister_chrdev_region(dev_t first, unsigned int count);
\end{mycode}

调用 \Colorbox{lightgrey}{\lstinline{unregister_chrdev_region}} 的地方常常是你的模块的 cleanup 函数。上面的函数分配设备编号给你的驱动使用，但是它们不告诉内核你实际上会对这些编号做什么。在用户空间程序能够存取这些设备号中一个之前，你的驱动需要连接它们到它的实现设备操作的内部函数上。我们将描述如何简短完成这个连接，但首先顾及一些必要的枝节问题。

\subsection{主编号的动态分配}

一些主设备编号是静态分派给最普通的设备的。一个这些设备的列表在内核源码树的 Documentation/devices.txt 中。分配给你的新驱动使用一个已经分配的静态编号的机会很小，但是，并且新编号没在分配。因此，作为一个驱动编写者，你有一个选择：你可以简单地捡一个看来没有用的编号，或者你以动态方式分配主编号。只要你是你的驱动的唯一用户就可以捡一个编号用；一旦你的驱动更广泛的被使用了，一个随机捡来的主编号将导致冲突和麻烦。

因此，对于新驱动，我们强烈建议你使用动态分配来获取你的主设备编号，而不是随机选取一个当前空闲的编号。换句话说，你的驱动应当几乎肯定地使用 \Colorbox{lightgrey}{\lstinline{alloc_chrdev_region}}，不是 \Colorbox{lightgrey}{\lstinline{register_chrdev_region}} 。

动态分配的缺点是你无法提前创建设备节点，因为分配给你的模块的主编号会变化。对于驱动的正常使用，这不是问题，因为一旦编号分配了，你可从 /proc/devices 中读取它。

为使用动态主编号来加载一个驱动，因此，可使用一个简单的脚本来代替调用 insmod ，在调用 insmod 后，读取 /proc/devices 来创建特殊文件。

一个典型的 /proc/devices 文件看来如下：

\begin{mycode}{/proc/devices}
Character devices:
1  mem
2  pty
3  ttyp
4  ttyS
6  lp
7  vcs
10 misc
13 input
14 sound

Block devices:
2  fd
8  sd
11 sr
65 sd
66 sd
\end{mycode}

因此加载一个已经安排了一个动态编号的模块的脚本，可以使用一个工具来编写，如 awk ，来从 /proc/devices 获取信息以创建 /dev 中的文件。

下面的脚本，snull\_load，是 scull 发布的一部分。以模块发布的驱动的用户可以从系统的 rc.local 文件中调用这样一个脚本，或者在需要模块时手工调用它。

\begin{mycode}{加载脚本}
#!/bin/sh
module="scull"
device="scull"
mode="664"

# 使用传入到该脚本的所有参数调用 insmod，同时使用路径名来指定模块位置，
# 这是因为新的modutils默认不会在当前目录中查找模块。
/sbin/insmod ./$module.ko $* || exit 1

# 删除原有节点
rm -f /dev/${device}[0-3]

major=$(awk "\\$2==\"$module\" {print \\$1}" /proc/devices)
mknod /dev/${device}0 c $major 0
mknod /dev/${device}1 c $major 1
mknod /dev/${device}2 c $major 2
mknod /dev/${device}3 c $major 3

# 给定适当的组属性以及许可，并修改属组。
# 并非所有的发行版都具有staff组，有些有wheel组。
group="staff"
grep -q '^staff:' /etc/group || group="wheel"
chgrp $group /dev/${device}[0-3]
chmod $mode /dev/${device}[0-3]
\end{mycode}

\chapter{块设备驱动程序}

\chapter{\texorpdfstring{$I^2C$客户端驱动程序}{I2C客户端驱动程序}}

由飞利浦（现为恩智浦）发明的$I^2C$总线是双线制：由串行数据（SDA）、串行时钟（SCL）构成的异步串行总线。它是多主总线，但多主模式未广泛使用。SDA和SCL都是漏极开路/集电极开路，这意味着它们都可以使输出驱动为低电平，但是如果没有上拉电阻，则都不能使输出驱动为高电平。SCL由主设备生成，以便在总线上同步数据（由SDA传送）传送。从机和主机都可以发送数据（当然不是同时），因此SDA是双向线路。这就是说SCL信号也是双向的，因为从机可以通过保持SCL线低电平来延长时钟。总线由主机控制，在这里的例子中它是SoC的一部分。该总线经常在嵌入式系统中，用于连接串行EEPROM、RTC芯片、GPIO扩展器、温度传感器等，如图\ref{fig:I2C总线示意图}所示。

\begin{figure}[htbp]
\centering
\tikzset{every picture/.style={line width=0.75pt}} %set default line width to 0.75pt        

\scalebox{0.5}{
\begin{tikzpicture}[x=0.75pt,y=0.75pt,yscale=-1,xscale=1]
%uncomment if require: \path (0,300); %set diagram left start at 0, and has height of 300

%Shape: Rectangle [id:dp5196207434278797] 
\draw   (37,83) -- (187,83) -- (187,185) -- (37,185) -- cycle ;
%Straight Lines [id:da5627473668996359] 
\draw    (188,119) -- (580,119) ;
%Straight Lines [id:da010662346115412724] 
\draw    (188,153) -- (580,153) ;
%Shape: Rectangle [id:dp010480578739430646] 
\draw  [fill={rgb, 255:red, 184; green, 233; blue, 134 }  ,fill opacity=1 ] (364,19) -- (472,19) -- (472,73) -- (364,73) -- cycle ;
%Shape: Rectangle [id:dp04190589424982427] 
\draw  [fill={rgb, 255:red, 184; green, 233; blue, 134 }  ,fill opacity=1 ] (207,221) -- (315,221) -- (315,275) -- (207,275) -- cycle ;
%Shape: Rectangle [id:dp4860326733837781] 
\draw  [fill={rgb, 255:red, 184; green, 233; blue, 134 }  ,fill opacity=1 ] (328,221) -- (436,221) -- (436,275) -- (328,275) -- cycle ;
%Shape: Rectangle [id:dp9524937334147969] 
\draw  [fill={rgb, 255:red, 184; green, 233; blue, 134 }  ,fill opacity=1 ] (454,221) -- (562,221) -- (562,275) -- (454,275) -- cycle ;
%Straight Lines [id:da8157092792166125] 
\draw    (228,121) -- (228,222) ;
%Straight Lines [id:da13363186575652009] 
\draw    (353,119) -- (353,220) ;
%Straight Lines [id:da1628282680825035] 
\draw    (480,119) -- (480,220) ;
%Straight Lines [id:da49332198915757886] 
\draw    (258,154) -- (260,221) ;
%Straight Lines [id:da9353008510448693] 
\draw    (384,153) -- (385,221) ;
%Straight Lines [id:da5599000501484221] 
\draw    (508,154) -- (510,221) ;
%Straight Lines [id:da7013725499426995] 
\draw    (393,74) -- (394,119) ;
%Straight Lines [id:da461479125348883] 
\draw    (426,73) -- (428,152) ;

% Text Node
\draw (67,125) node [anchor=north west][inner sep=0.75pt]   [align=left] {CPU（主机）};
% Text Node
\draw (591,111) node [anchor=north west][inner sep=0.75pt]   [align=left] {SCL};
% Text Node
\draw (590,142) node [anchor=north west][inner sep=0.75pt]   [align=left] {SDA};
% Text Node
\draw (372,38) node [anchor=north west][inner sep=0.75pt]   [align=left] {从机3（0x63）};
% Text Node
\draw (215,241) node [anchor=north west][inner sep=0.75pt]   [align=left] {从机1（0x55）};
% Text Node
\draw (337,241) node [anchor=north west][inner sep=0.75pt]   [align=left] {从机2（0x22）};
% Text Node
\draw (462,240) node [anchor=north west][inner sep=0.75pt]   [align=left] {从机4（0x51）};
\end{tikzpicture}}
\caption{$I^2C$总线和设备}
\label{fig:I2C总线示意图}
\end{figure}

时钟频率为10 kHz~100 kHz,400 kHz~2 MHz不等。本教程不涉及总线规范或总线驱动程序。然而，总线驱动程序应该管理总线并符合总线规范。i.MX6芯片的总线驱动程序示例可在内核源代码drivers/i2c/busses/i2c-imx.c中找到。

本章集中介绍客户端驱动程序，以便处理该总线上的从设备。本章涉及以下主题。

\begin{itemize}
\item $I^2C$客户驱动程序架构。
\item 设备访问，从设备中读/写设备数据。
\item 在DT中声明客户端设备。
\end{itemize}

\section{驱动程序架构}

当为其编写驱动程序的设备位于物理总线（被称作总线控制器）上时，它一定依赖总线的驱动程序，也就是控制器驱动程序，它负责在设备之间共享总线访问。控制器驱动程序在设备和总线之间提供抽象层。例如，当在$I^2C$或USB总线上执行事务（读取或写入）时，$I^2C$/USB总线控制器将在后台透明地处理该事务。每个总线控制器驱动程序都提供一组函数，以简化位于该总线上设备驱动程序的开发。这适用于每个物理总线（$I^2C$、SPI、USB、PCI、SDIO等）。$I^2C$驱动程序在内核中表示为\Colorbox{lightgrey}{\lstinline{struct i2c_driver}}的实例。$I^2C$客户端（代表设备本身）由\Colorbox{lightgrey}{\lstinline{struct i2c_client}}结构表示。

\subsection{i2c\_driver结构}

$I^2C$驱动程序在内核中声明为\Colorbox{lightgrey}{\lstinline{struct i2c_driver}}实例，它看起来像下面这样:

\begin{mycode}{i2c\_driver}
struct i2c_driver {
    /* 标准驱动模型接口 */
    int (*probe)(struct i2c_client *, const struct i2c_device_id *);
    int (*remove)(struct i2c_client *);
    /* 与枚举无关的驱动类型接口 */
    void (*shutdown)(struct i2c_client *);
    struct device_driver driver;
    const struct i2c_device_id *id_table;
};
\end{mycode}

\Colorbox{lightgrey}{\lstinline{struct i2c_driver}}结构包含并描述通用访问例程，这些例程是处理声明驱动程序的设备所必需的，而\Colorbox{lightgrey}{\lstinline{struct i2c_client}}则包含设备特有的信息，如其地址。\Colorbox{lightgrey}{\lstinline{struct i2c_client}}结构表示和描述$I^2C$设备。本章后面的部分将介绍如何填充这些结构。

1. probe函数

probe函数是\Colorbox{lightgrey}{\lstinline{struct i2c_driver}}结构的一部分，在$I^2C$器件实例化后随时执行。它负责以下任务。

\begin{itemize}
    \item 检查设备是否是所期望的。
    \item 使用\Colorbox{lightgrey}{\lstinline{i2c_check_functionality}}函数检查SoC的$I^2C$总线控制器是否支持设备所需的功能。
    \item 初始化设备。
    \item 设置设备特定的数据。
    \item 注册合适的内核框架。
\end{itemize}

probe函数的原型如下：

\begin{mycode}{probe函数的原型}
static int foo_probe(struct i2c_client *client, const struct i2c_device_id *id)
\end{mycode}

各参数说明如下。

\begin{itemize}
    \item \Colorbox{lightgrey}{\lstinline{struct i2c_client}}指针：代表$I^2C$设备本身。该结构继承自device结构，由内核提供给probe函数。客户端结构在\Colorbox{lightgrey}{\lstinline{include/linux/i2c.h}}中定义。其定义如下：
\begin{mycode}{i2c\_client}
struct i2c_client {
    unsigned short flags;
    /// 芯片地址：7位。地址被存储在addr的低7位。
    unsigned short addr;
    char name[I2C_NAME_SIZE];
    /// 适配器
    struct i2c_adapter *adapter;
    /// 设备结构
    struct device dev;
    /// 设备发出的中断请求
    intirq;
    struct list_head detected;
#if IS_ENABLED(CONFIG_I2C_SLAVE)
    /// 从设备的回调函数
    i2c_slave_cb_t slave_cb;
#endif
};
\end{mycode}
    \item 所有字段由内核基于注册客户端时所提供的参数进行填充。稍后会看到如何将设备注册到内核。
    \item \Colorbox{lightgrey}{\lstinline{struct i2c_device_id}}指针：指向与正在探测的设备相匹配的$I^2C$设备ID项。
\end{itemize}

$I^2C$内核使用户能够存储指向其所选任何数据结构的指针，把它作为设备特定数据。要存储或检索数据，请使用$I^2C$内核提供的以下函数：

\begin{mycode}{$I^2C$内核提供的函数}
/// 设置数据
void i2c_set_clientdata(struct i2c_client *client, void *data);
/// 获取数据
void *i2c_get_clientdata(const struct i2c_client *client);
\end{mycode}

这些函数在内部调用\Colorbox{lightgrey}{\lstinline{dev_set_drvdata}}和\Colorbox{lightgrey}{\lstinline{dev_get_drvdata}}来更新或获取\Colorbox{lightgrey}{\lstinline{struct i2c_client}}结构中\Colorbox{lightgrey}{\lstinline{struct device}}子结构的\Colorbox{lightgrey}{\lstinline{void * driver_data}}字段的值。

\section{总结}

学会如何处理$I^2C$设备驱动程序之后，可以付诸实践了：在市场上选购任一款$I^2C$设备，编写相应的驱动程序，并支持DT。

本章讨论了内核中的$I^2C$内核和相关的API，包括设备树支持，介绍了与$I^2C$设备通信的必要技能。读者现在应该能够编写出高效的probe函数，并注册到$I^2C$内核中了。第8章将使用在这里学到的技能开发SPI设备驱动程序。

\part{Linux移植}

\chapter{移植到SD卡}

本次实验宿主机使用全新的Ubuntu20.04环境，并在完成实验后用户目录下有以下结构的文件夹。

首先需要创建架构。

\begin{mycode}{文件结构}
v3s-workspace
- linux
- partitions
-- boot
--- boot.scr
--- sun8i-v3s-licheepi-zero-dock.dtb
--- zImage
-- root
- u-boot
- modules
- buildroot
- boot.cmd
\end{mycode}

然后下载所有本次实验会使用到的代码和依赖。

\begin{mycode}{安装依赖}
# 安装依赖
sudo apt-get install flex bison gcc make gcc-arm-linux-gnueabihf libncurses-dev swig python-dev device-tree-compiler python3-setuptools python3-dev libssl-dev u-boot-tools g++ patch

# 下载Mainline Linux,你可以在https://www.kernel.org寻找最新的LTS版本
wget https://cdn.kernel.org/pub/linux/kernel/v6.x/linux-6.1.19.tar.xz
# extract是zsh提供的自动解压指令，可以替换成tar的对应格式解压指令
extract linux-6.1.19.tar.xz
mv linux-6.1.19 linux

# 下载U-Boot，我们这里没有使用LTS版本，你可以进入cd进去后切换到LTS分支
git clone git://git.denx.de/u-boot.git

# 下载Buildroot，你可以在https://buildroot.org/downloads寻找最新的版本
wget https://buildroot.org/downloads/buildroot-2023.02.tar.xz
extract buildroot-2023.02.tar.xz
mv buildroot-2023.02 buildroot
\end{mycode}

每一章节结束后请返回\Colorbox{lightgrey}{\lstinline{v3s-workspace}}目录。

\section{编译U-Boot}

\begin{mycode}{编译U-Boot}
cd u-boot
# 使用荔枝派Nano的默认配置
make CROSS_COMPILE=arm-linux-gnueabihf- LicheePi_Zero_defconfig
# 编译
make CROSS_COMPILE=arm-linux-gnueabihf-
# 拷贝U-Boot镜像
cp u-boot-sunxi-with-spl.bin ../partitions
\end{mycode}

接下来我们需要准备U-Boot启动所需的配置文件，将以下内容写入boot.cmd。

\begin{mycode}
setenv bootargs console=tty0 console=ttyS0,115200 panic=5 rootwait root=/dev/mmcblk0p2 rw
load mmc 0:1 0x43000000 sun8i-v3s-licheepi-zero-dock.dtb
load mmc 0:1 0x42000000 zImage
bootz 0x42000000 - 0x43000000
\end{mycode}

接着编译配置文件。

\begin{mycode}{编译配置文件}
mkimage -C none -A arm -T script -d boot.cmd ./partitions/boot/boot.scr
\end{mycode}

\section{编译Linux内核}

\begin{mycode}{配置编译}
cd linux
# 使用linux-sunxi项目的默认配置，该项目主要包含全志各芯片的硬件支持文档和手册
make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- sunxi_defconfig
# 进入内核配置菜单
make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- menuconfig
\end{mycode}

\begin{marker}
    在内核配置菜单中，将 \Colorbox{lightgrey}{\lstinline{Networking support > Wireless}} 中的选项全部选中。
\end{marker}

我们需要修改\Colorbox{lightgrey}{\lstinline{arch/arm/boot/dts/sun8i-v3s-licheepi-zero.dts}}以启用以太网和USB支持。

\begin{mycode}{设备树文件}
/dts-v1/;
#include "sun8i-v3s.dtsi"
#include "sunxi-common-regulators.dtsi"

/ {
    model = "Lichee Pi Zero";
    compatible = "licheepi,licheepi-zero", "allwinner,sun8i-v3s";

    aliases {
        serial0 = &uart0;
        ethernet0 = &emac; /* 添加这一行 */
    };

    chosen {
        stdout-path = "serial0:115200n8";
    };

    leds {
        compatible = "gpio-leds";

        blue_led {
            label = "licheepi:blue:usr";
            gpios = <&pio 6 1 GPIO_ACTIVE_LOW>; /* PG1 */
        };

        green_led {
            label = "licheepi:green:usr";
            gpios = <&pio 6 0 GPIO_ACTIVE_LOW>; /* PG0 */
            default-state = "on";
        };

        red_led {
            label = "licheepi:red:usr";
            gpios = <&pio 6 2 GPIO_ACTIVE_LOW>; /* PG2 */
        };
    };

  /* 添加以下soc部分 */
    soc {
        ehci0: usb@01c1a000 {
            compatible = "allwinner,sun8i-v3s-ehci", "generic-ehci";
            reg = <0x01c1a000 0x100>;
            interrupts = <GIC_SPI 72 IRQ_TYPE_LEVEL_HIGH>;
            clocks = <&ccu CLK_BUS_EHCI0>, <&ccu CLK_BUS_OHCI0>;
            resets = <&ccu RST_BUS_EHCI0>, <&ccu RST_BUS_OHCI0>;
            status = "okay";
        };

        ohci0: usb@01c1a400 {
            compatible = "allwinner,sun8i-v3s-ohci", "generic-ohci";
            reg = <0x01c1a400 0x100>;
            interrupts = <GIC_SPI 73 IRQ_TYPE_LEVEL_HIGH>;
            clocks = <&ccu CLK_BUS_EHCI0>, <&ccu CLK_BUS_OHCI0>,
            <&ccu CLK_USB_OHCI0>;
            resets = <&ccu RST_BUS_EHCI0>, <&ccu RST_BUS_OHCI0>;
            status = "okay";
        };
    };
};

&mmc0 {
    broken-cd;
    bus-width = <4>;
    vmmc-supply = <&reg_vcc3v3>;
    status = "okay";
};

&uart0 {
    pinctrl-0 = <&uart0_pb_pins>;
    pinctrl-names = "default";
    status = "okay";
};

&usb_otg {
    dr_mode = "host";
    status = "okay";
};

&usbphy {
    usb0_id_det-gpios = <&pio 5 6 GPIO_ACTIVE_LOW>;
    status = "okay";
};

/* 添加emac部分 */
&emac {
    allwinner,leds-active-low;
    status = "okay";
};
\end{mycode}


接着执行以下指令。

\begin{mycode}{编译内核}
# 编译内核，-j4的4可以修改为你的CPU核心数
ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- make -j4 zImage
# 编译DTB文件，本文件用于Kernel识别外设，是 Mainline Kernel不可缺少的部分，-j4的4可以修改为你的CPU核心数
ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- make -j4 dtbs
# 编译Modules，-j4的4可以修改为你的CPU核心数
ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- make -j4 modules
# 安装模块
ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- INSTALL_MOD_PATH=../modules  make modules modules_install
# 拷贝生成的zImage内核镜像和DTB文件
cp arch/arm/boot/zImage ../partitions/boot
cp arch/arm/boot/dts/sun8i-v3s-licheepi-zero-dock.dtb ../partitions/boot
\end{mycode}

\section{编译Buildroot}

我们使用Buildroot默认的busybox程序和glibc，如果需要剪裁大小，可以选择其他的C支持库。

\begin{mycode}{配置菜单}
$ cd
$ make menuconfig
\end{mycode}

\begin{table}[ht]
\begin{adjustbox}{width=1\textwidth}
\begin{tabular}{|l|l|l|}
\hline
配置位置                                                    & 操作                                                & 用途                        \\
\hline
Target options                                             & Target Arch设置为ARM (little endian)                & 设置大小端                     \\
Target options                                             & Target Arch Variant设置为Cortex-A7                  & 设置CPU架构                   \\
Toolchain                                                  & Kernel Headers设置为你下载的LTS版本内核对应的版本号      & 匹配内核版本                    \\
Target packages \textgreater Networking applications       & hostapd                                            & 开启                        \\
Target packages \textgreater Networking applications       & hostapd \textgreater Enable hostap driver          & 开启                        \\
Target packages \textgreater Networking applications       & hostapd \textgreater Enable nl80211 driver         & 开启                        \\
Target packages \textgreater Networking applications       & hostapd \textgreater Enable ACS                    & 开启                        \\
Target packages \textgreater Networking applications       & hostapd \textgreater Enable EAP                    & 开启                        \\
Target packages \textgreater Networking applications       & hostapd \textgreater Enable WPS                    & 开启                        \\
Target packages \textgreater Networking applications       & openssh                                            & 开启                        \\
Target packages \textgreater Networking applications       & openssh \textgreater client                        & 开启                        \\
Target packages \textgreater Networking applications       & openssh \textgreater server                        & 开启                        \\
Target packages \textgreater Networking applications       & openssh \textgreater key utilities                 & 开启                        \\
Target packages \textgreater Networking applications       & openssh \textgreater use sandboxing                & 开启                        \\
Target packages \textgreater Networking applications       & wireless tools                                     & 开启                        \\
Target packages \textgreater Networking applications       & wireless tools \textgreater Install shared library & 开启                        \\
Target packages \textgreater Networking applications       & wpa\_supplicant                                    & 开启                        \\
Target packages \textgreater Libraries \textgreater Crypto & openssl support                                    & openssl support的子菜单部件全部选中 \\
\hline
\end{tabular}
\end{adjustbox}
\end{table}

执行以下命令

\begin{mycode}{编译跟文件系统rootfs}
# 编译，Buildroot不支持多线程编译，所以不携带-j
make
# 拷贝解压文件系统和内核模块
cp output/images/rootfs.tar ../partitions/root
cd ../partitions/root
extract rootfs.tar
mv rootfs/* ./
rm -rf rootfs
rm rootfs.tar
cp -R ../../modules/* ./
\end{mycode}

同时修改partitions/root/etc/fstab文件中的ext2为ext4。

\section{写入SD卡}

我的SD卡路径是/dev/sdb，可以通过sudo fdisk -l查看SD卡的路径。

\begin{mycode}{将UBoot写入SD卡}
cd partitions
# 清空分区表
sudo dd if=/dev/zero of=/dev/sdb bs=1M count=1
# 写入U-Boot
sudo dd if=u-boot-sunxi-with-spl.bin of=/dev/sdb bs=1024 seek=8
\end{mycode}

\begin{mycode}{将分区表写入SD卡}
# 写入分区表，请复制除了本行内的内容并执行
sudo blockdev --rereadpt /dev/sdb
cat <<EOT | sudo sfdisk /dev/sdb
1M,16M,c
,,L
EOT
\end{mycode}

\begin{mycode}{将内核和根文件系统写入SD卡}
# 格式化
sudo mkfs.vfat /dev/sdb1
sudo mkfs.ext4 /dev/sdb2
# 拷贝boot进入第一个分区
sudo mount /dev/sdb1 /mnt
sudo cp -R boot/* /mnt
sync
sudo umount /mnt
# 拷贝rootfs进入第二个分区
sudo mount /dev/sdb2 /mnt
sudo cp -R root/* /mnt
sync
sudo umount /mnt
\end{mycode}

\section{将开发板作为ssh服务器来使用}

连接串口，波特率设置为 115200 。

使用 putty 软件连接嵌入式Linux开发板。

\begin{mycode}{启动sshd服务}
vi /etc/ssh/sshd_config
# 将文件中的PermitRootLogin设置为yes
# PermitRootLogin yes
# 保存退出

# 使用passwd设置密码
passwd
# 启动sshd服务
/usr/sbin/sshd
\end{mycode}

\begin{marker}
这里建议重启一下板子，否则 /etc/ssh/sshd\_config 不一定能够生效，我实测时就是需要重启才可以。
\end{marker}


\begin{mycode}{启动以太网服务}
ifconfig eth0 up
udhcpc
\end{mycode}

\section{安装无线网卡驱动}

\begin{mycode}{安装无线网卡驱动}
cd v3s-workspace
git clone https://github.com/al177/esp8089.git
cd esp8089
ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- make -C ../linux/ M=${PWD} modules

# 172.17.0.58替换为你的电脑看到的Linux开发板的ip地址。
scp esp8089.ko root@172.17.0.58:/root/
ssh root@172.17.0.58
# 进入嵌入式Linux开发板之后的操作
# 加载wifi驱动
atguigu-pi>insmod esp8089.ko
atguigu-pi>ifconfig wlan0 up
atguigu-pi>wpa_passphrase your_SSID your_passphrase > your_SSID.conf
atguigu-pi>wpa_supplicant -B -i wlan0 -c your_SSID.conf
\end{mycode}

\part{驱动程序举例}



\chapter{V3S按键驱动}

我们的开发板上面，有5个按键本身不是通过gpio连接到soc上面的。它是通过adc的方法，连接到主芯片的。这个时候，不同的按键被按下的时候，就会生成不同的电压或者电流，那么完全可以根据对应的电信号，推算出当前是哪一个按键被按下去了。

简单看一下电路之后，下面就是去找设备树，对应的信号是什么、在哪里。

\section{查找设备树}

在sun8i-v3s-licheepi-zero-dock.dts文件当中，我们发现了这样的内容，

\begin{mycode}{设备树}
&lradc {
    vref-supply = <&reg_vcc3v0>;
    status = "okay";
 
    button@200 {
        label = "Volume Up";
        linux,code = <KEY_VOLUMEUP>;
        channel = <0>;
        voltage = <200000>;
    };
 
    button@400 {
        label = "Volume Down";
        linux,code = <KEY_VOLUMEDOWN>;
        channel = <0>;
        voltage = <400000>;
    };
 
    button@600 {
        label = "Select";
        linux,code = <KEY_SELECT>;
        channel = <0>;
        voltage = <600000>;
    };
 
    button@800 {
        label = "Start";
        linux,code = <KEY_OK>;
        channel = <0>;
        voltage = <800000>;
    };
};
\end{mycode}

很明显，每一个button都是和电路中的按键是一一对应的，这个没有问题。那么，我们不禁还有一个疑问，既然是ad转换得到的结果，那么肯定要知道ad相关的设备配置是恶还那么。仔细找了一下，可以在sun8i-v3s.dtsi文件发现这样的内容，

\begin{mycode}{lradc的配置}
lradc: lradc@01c22800 {
    compatible = "allwinner,sun4i-a10-lradc-keys";
    reg = <0x01c22800 0x400>;
    interrupts = <GIC_SPI 30 IRQ_TYPE_LEVEL_HIGH>;
    status = "disabled";
};
\end{mycode}

看到这里，大家应该放心了，确实是有这么一个ad的驱动。兼容的设备是sun4i-a10-lradc-keys，寄存器地址空间是0x01c22800，长度是0x400，中断是GIC\_SPI类型，状态关闭。有了设备树，还有了兼容设备号，接下来的一步就是根据设备号sun4i-a10-lradc-keys找到对应的驱动文件。

\section{查找驱动代码，准备测试程序}

通过工具查找一下，不难发现，文件在这，即sun4i-lradc-keys.c，

\begin{mycode}{ad驱动代码}
static const struct of_device_id sun4i_lradc_of_match[] = {
    { .compatible = "allwinner,sun4i-a10-lradc-keys", },
    { /* sentinel */ }
};
MODULE_DEVICE_TABLE(of, sun4i_lradc_of_match);

static struct platform_driver sun4i_lradc_driver = {
    .driver = {
        .name    = "sun4i-a10-lradc-keys",
        .of_match_table = of_match_ptr(sun4i_lradc_of_match),
    },
    .probe    = sun4i_lradc_probe,
};

module_platform_driver(sun4i_lradc_driver);

MODULE_DESCRIPTION("Allwinner sun4i low res adc attached tablet keys driver");
MODULE_AUTHOR("Hans de Goede <hdegoede@redhat.com>");
MODULE_LICENSE("GPL");    
\end{mycode}

一般来说，如果按键ok的话，会在设备启动的时候生成个/dev/input/event0节点，此时，如果编写一个应用程序，读写这些节点，就完全可以获取相关的按键信息。所以，我们还得准备一个input.c的读写程序，

\begin{mycode}{input.c}
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <errno.h>
#include <linux/input.h>
#include <linux/input-event-codes.h>

const char * path = "/dev/input/event0";

int main(char argc,char *argv[])
{
    int ret;

    int fd;
    struct input_event event;

    fd = open(path,O_RDONLY);
    if(fd < 0)
    {
        perror(path);
        exit(-1);
    }

    while(1)
    {
        ret = read(fd, &event, sizeof(struct input_event));
        if(ret == sizeof(struct input_event))
        {
            if(event.type != EV_SYN)
            {
                printf("Event: time %ld.%ld,", event.time.tv_sec, event.time.tv_usec);
                printf("type:%d,code:%d,value:%d\n", event.type,event.code, event.value);
            }
        }
    }
 
    close(fd);

    return 0;
}
\end{mycode}

准备好了程序之后，下面就是交叉编译，下载到开发板上面。但是实际运行的时候，发现按键被按下的时候，有三个按键的数值居然是一样的，都是352，另外一个是114。这就非常蹊跷了。

\section{解决问题}

查看sun4i-lradc-keys.c，惊讶地发现电压判断标准是根据sun8i-v3s-licheepi-zero-dock.dts中的voltage来验证的，这并不符合实际的情况。我们通过printk\&dmesg打印，也验证了这一想法，所以如果需要得到正确的按键数值，只需要修正一下sun4i-lradc-keys.c中的判断逻辑就可以了，修改方法如下，具体的标定数值可以做实验来解决，

\begin{mycode}{修改程序}
#if 0
        voltage = val * lradc->vref / 63;

        for (i = 0; i < lradc->chan0_map_count; i++) {
            diff = abs(lradc->chan0_map[i].voltage - voltage);
            if (diff < closest) {
                closest = diff;
                keycode = lradc->chan0_map[i].keycode;
            }
        }
#else
        printk("val = %d\n", val);
        if(val >=9 && val <= 13)
            keycode = lradc->chan0_map[0].keycode;
        else if(val >=24 && val <= 29)
            keycode = lradc->chan0_map[1].keycode;
        else if(val >= 35 && val <= 40)
            keycode = lradc->chan0_map[2].keycode;
        else
            keycode = lradc->chan0_map[3].keycode;
#endif
\end{mycode}

经过这一次修改，我们重新编译kernel内核，烧入zImage，启动后输入key程序，这样就得到了我们想要的最终结果，即稳定地输出按键值。

\chapter{GPIO驱动示例-1}

使用spi接口当成gpio口。

有一个spi接口，之前主要是用作norflash访问使用的。现在因为所有系统都保存在sd卡里面，因此完全可以用这个当成gpio使用。

修改sun8i-v3s.dtsi文件

首先注释掉之前spi0\_pins这个部分，

\begin{mycode}{修改设备树文件}
/*spi0_pins: spi0 {
    pins = "PC0", "PC1", "PC2", "PC3";
    function = "spi0";
};*/
\end{mycode}

接着注释掉spi0，

\begin{mycode}{修改设备树文件}
/*spi0: spi@1c68000 {
    compatible = "allwinner,sun8i-h3-spi";
    reg = <0x01c68000 0x1000>;
    interrupts = <GIC_SPI 65 IRQ_TYPE_LEVEL_HIGH>;
    clocks = <&ccu CLK_BUS_SPI0>, <&ccu CLK_SPI0>;
    clock-names = "ahb", "mod";
    pinctrl-names = "default";
    pinctrl-0 = <&spi0_pins>;
    resets = <&ccu RST_BUS_SPI0>;
    status = "disabled";
    #address-cells = <1>;
    #size-cells = <0>;
};*/
\end{mycode}

注释掉这两部分呢，重新编译成sun8i-v3s-licheepi-zero-dock.dtb文件就可以了。细心的同学也许会看到sun8i-v3s-licheepi-zero.dts和sun8i-v3s-licheepi-zero-dock.dts这两个文件中均有leds的配置，是不是status设置为okay就好了？要注意它们的状态都是写死的，后期不能通过命令和配置的方法来解决，虽然启动后也可以在/sys/kernel/debug/gpio下面看到映射关系，这个需要注意下。

重启开发板

重启开发板之后，首先需要查看一下端口使用情况，没有debug信息，先要mount debugfs系统，

\begin{mycode}{shell}
mount -t debugfs debugfs /sys/kernel/debug
# 加载好了之后，就可以看看端口的使用情况了，
cat /sys/kernel/debug/gpio
\end{mycode}

创建通道，开始设备外设

看过上面一篇文章的同学，对于/sys/class/pwm里面的export不会陌生。但是pwm只有两个，分别是0和1，gpio这么多，我们怎么把这些pin和通道bind在一起呢？其实这里面是有规律的。首先我们找到一个pin，但不知道它的序号是多少，那可以先找到名称，比如SPI\_CS,接着看\Colorbox{lightgrey}{\lstinline{Allwinner_V3s_Datasheet_V1.0.pdf}}中的第54页，获取引脚名称，

找到了这个信号叫PC2，下面就好办了。所有的端口一般都是$channel = 32 \times x+y$来实现的。PA、PB、PC...，这些代表$x$，分别是0、1、2...。而PC2中的2就代表$y$，如果是PB9，那么$y$就是9。所以对于PC2来说，$channel = 32 \times 2+ 2$，也就是66，就是这么简单。那么，刚才说的PB9呢，它的$channel = 32 \times 1 + 9$，应该就是41。

说了这么多，下面开始实验，

\begin{mycode}{shell}
echo 66 > /sys/class/gpio/export
echo out > /sys/class/gpio/gpio66/direction
echo 1 > /sys/class/gpio/gpio66/value
echo 0 > /sys/class/gpio/gpio66/value
\end{mycode}

四条命令依次解释下，第一条创建channel 66。第二条呢，设定chanel 66的方向为输出。第三条，设置高电平，与此相对的，第四条就是设置低电平。

为了验证设置的电平是不是正确，一个靠谱的办法就是在spi\_cs处于高电平和低电平的时候都测量下，这样就知道电压有没有设置对了。

\chapter{GPIO驱动示例-2}

\begin{mycode}{gpio\_driver.c}
#include <linux/module.h>
#include <linux/init.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/uaccess.h>
#include <linux/gpio.h>

/* Meta Information */
MODULE_LICENSE("GPL");
MODULE_AUTHOR("Atguigu GNU/Linux");
MODULE_DESCRIPTION("A simple gpio driver for setting a LED and reading a button");

/* Variables for device and device class */
static dev_t my_device_nr;
static struct class *my_class;
static struct cdev my_device;

#define DRIVER_NAME "my_gpio_driver"
#define DRIVER_CLASS "MyModuleClass"

/**
 * @brief 将数据从缓冲区中读出
 */
static ssize_t driver_read(struct file *File, char *user_buffer, size_t count, loff_t *offs) {
    int to_copy, not_copied, delta;
    char tmp[3] = " \n";

    /* Get amount of data to copy */
    to_copy = min(count, sizeof(tmp));

    /* Read value of button */
    printk("Value of button: %d\n", gpio_get_value(17));
    tmp[0] = gpio_get_value(17) + '0';

    /* Copy data to user */
    not_copied = copy_to_user(user_buffer, &tmp, to_copy);

    /* Calculate data */
    delta = to_copy - not_copied;

    return delta;
}

/**
 * @brief 将数据写入缓冲区
 */
static ssize_t driver_write(struct file *File, const char *user_buffer, size_t count, loff_t *offs) {
    int to_copy, not_copied, delta;
    char value;

    /* Get amount of data to copy */
    to_copy = min(count, sizeof(value));

    /* Copy data to user */
    not_copied = copy_from_user(&value, user_buffer, to_copy);

    /* Setting the LED */
    switch(value) {
        case '0':
            gpio_set_value(4, 0);
            break;
        case '1':
            gpio_set_value(4, 1);
            break;
        default:
            printk("Invalid Input!\n");
            break;
    }

    /* Calculate data */
    delta = to_copy - not_copied;

    return delta;
}

/**
 * @brief 当设备文件打开时，调用这个函数
 */
static int driver_open(struct inode *device_file, struct file *instance) {
    printk("dev_nr - open was called!\n");
    return 0;
}

/**
 * @brief 当设备文件关闭时，调用这个函数
 */
static int driver_close(struct inode *device_file, struct file *instance) {
    printk("dev_nr - close was called!\n");
    return 0;
}

static struct file_operations fops = {
    .owner = THIS_MODULE,
    .open = driver_open,
    .release = driver_close,
    .read = driver_read,
    .write = driver_write
};

/**
 * @brief 当模块加载进内核时，调用这个函数
 */
static int __init ModuleInit(void) {
    printk("Hello, Kernel!\n");

    /* Allocate a device nr */
    if( alloc_chrdev_region(&my_device_nr, 0, 1, DRIVER_NAME) < 0) {
        printk("Device Nr. could not be allocated!\n");
        return -1;
    }
    printk("read_write - Device Nr. Major: %d, Minor: %d was registered!\n", my_device_nr >> 20, my_device_nr && 0xfffff);

    /* 创建设备类 */
    if((my_class = class_create(THIS_MODULE, DRIVER_CLASS)) == NULL) {
        printk("Device class can not be created!\n");
        goto ClassError;
    }

    /* 创建设备文件 */
    if(device_create(my_class, NULL, my_device_nr, NULL, DRIVER_NAME) == NULL) {
        printk("Can not create device file!\n");
        goto FileError;
    }

    /* 初始化设备文件 */
    cdev_init(&my_device, &fops);

    /* 将设备注册到内核 */
    if(cdev_add(&my_device, my_device_nr, 1) == -1) {
        printk("Registering of device to kernel failed!\n");
        goto AddError;
    }

    /* GPIO 4 init */
    if(gpio_request(4, "rpi-gpio-4")) {
        printk("Can not allocate GPIO 4\n");
        goto AddError;
    }

    /* Set GPIO 4 direction */
    if(gpio_direction_output(4, 0)) {
        printk("Can not set GPIO 4 to output!\n");
        goto Gpio4Error;
    }

    /* GPIO 17 init */
    if(gpio_request(17, "rpi-gpio-17")) {
        printk("Can not allocate GPIO 17\n");
        goto Gpio4Error;
    }

    /* Set GPIO 17 direction */
    if(gpio_direction_input(17)) {
        printk("Can not set GPIO 17 to input!\n");
        goto Gpio17Error;
    }


    return 0;
Gpio17Error:
    gpio_free(17);
Gpio4Error:
    gpio_free(4);
AddError:
    device_destroy(my_class, my_device_nr);
FileError:
    class_destroy(my_class);
ClassError:
    unregister_chrdev_region(my_device_nr, 1);
    return -1;
}

/**
 * @brief 当模块从内核中移除时，调用这个函数
 */
static void __exit ModuleExit(void) {
    gpio_set_value(4, 0);
    gpio_free(17);
    gpio_free(4);
    cdev_del(&my_device);
    device_destroy(my_class, my_device_nr);
    class_destroy(my_class);
    unregister_chrdev_region(my_device_nr, 1);
    printk("Goodbye, Kernel\n");
}

module_init(ModuleInit);
module_exit(ModuleExit);
\end{mycode}

Makefile文件如下

\begin{mycode}{Makefile}
obj-m += gpio_driver.o

all:
    make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules

clean:
    make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean
\end{mycode}

\chapter{PWM驱动示例-1}

要使能pwm功能，最主要就是修改设备树配置文件，

第一，在sun8i-v3s.dtsi中，添加pwm0和pwm1节点，

\begin{mycode}{pwm设备树}
pwm0_pins: pwm0 {
    pins = "PB4";
    function = "pwm0";
};

pwm1_pins: pwm1 {
    pins = "PB5";
    function = "pwm1";
};
\end{mycode}

第二，在sun8i-v3s-licheepi-zero.dts中使能pwm，

\begin{mycode}{使能pwm}
&pwm {
    pinctrl-names = "default";
    pinctrl-0 = <&pwm0_pins>, <&pwm1_pins>;
    status = "okay";
};
\end{mycode}

修改了这两个文件，下面要做的就是把他们编译成dtb，下载到sd卡里面，等待重启即可。注意，拷贝的dtb文件是un8i-v3s-licheepi-zero-dock.dtb。

如果对驱动代码有兴趣，可以通过sun8i-v3s-pwm这个关键字去查找一下。查找后发现，相关的驱动文件名是drivers/pwm/pwm-sun4i.c。

此外，之前这份驱动已经包含在了zImage里面，所以不需要重新编译内核。

前面如果大家做过实验，就可以发现，如果我们没有修改设备树文件，那么发现在/sys/class/pwm节点下什么也没有。但是修改了之后，就会发现/sys/class/pwm一下子多了很多的内容，

\begin{mycode}{显示内容}
# cd /sys/class
# cd pwm/
# ls
pwmchip0
# cd pwmchip0/
# ls
device     export     npwm       power      subsystem  uevent     unexport
# ls -l
total 0
lrwxrwxrwx    1 root     root             0 Jan  1 00:31 device -> ../../../1c21400.pwm
--w-------    1 root     root          4096 Jan  1 00:31 export
-r--r--r--    1 root     root          4096 Jan  1 00:31 npwm
drwxr-xr-x    2 root     root             0 Jan  1 00:31 power
lrwxrwxrwx    1 root     root             0 Jan  1 00:31 subsystem -> ../../../../../../class/pwm
-rw-r--r--    1 root     root          4096 Jan  1 00:31 uevent
--w-------    1 root     root          4096 Jan  1 00:31 unexport
\end{mycode}

首先，我们可以通过export来使能通道，输入0就可以创建通道0，输入1就可以创建通道1，根据具体情况而定。

\begin{mycode}{举例}
echo 0 > /sys/class/pwm/pwmchip0/export
# 通道创建好了，就可以进入到通道里面，看看有哪些配置。以通道0为例，
cd pwm0
ls
\end{mycode}

简单来说，可以通过三个数值就可以实现最基本的pwm功能。其中period代表频率，duty\_cycle代表空占比，enable代表使能开关，

\begin{mycode}{设置pwm波的参数}
echo 1000000 > /sys/class/pwm/pwmchip0/pwm0/period
echo 500000 > /sys/class/pwm/pwmchip0/pwm0/duty_cycle
echo 1 > /sys/class/pwm/pwmchip0/pwm0/enable
echo 0 > /sys/class/pwm/pwmchip0/pwm0/enable
\end{mycode}

假设cpu频率是1GHz，而我们希望得到的pwm频率是1000，那么这里的period就是1G/1000，而duty\_cycle被设置成了500000，代表空占比是50\%，enable为1代表打开，0则代表关闭。通道1也是这个道理，用同样的方法配置一下即可。

使用逻辑分析仪来观察一下。

\chapter{PWM驱动示例-2}

驱动程序如下

\begin{mycode}{pwm\_driver.c}
#include <linux/module.h>
#include <linux/init.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/uaccess.h>
#include <linux/pwm.h>

/* Meta Information */
MODULE_LICENSE("GPL");
MODULE_AUTHOR("Johannes 4 GNU/Linux");
MODULE_DESCRIPTION("A simple driver to access the Hardware PWM IP");

/* Variables for device and device class */
static dev_t my_device_nr;
static struct class *my_class;
static struct cdev my_device;

#define DRIVER_NAME "my_pwm_driver"
#define DRIVER_CLASS "MyModuleClass"

/* Variables for pwm  */
struct pwm_device *pwm0 = NULL;
u32 pwm_on_time = 500000000;

/**
 * @brief Write data to buffer
 */
static ssize_t driver_write(struct file *File, const char *user_buffer, size_t count, loff_t *offs) {
    int to_copy, not_copied, delta;
    char value;

    /* Get amount of data to copy */
    to_copy = min(count, sizeof(value));

    /* Copy data to user */
    not_copied = copy_from_user(&value, user_buffer, to_copy);

    /* Set PWM on time */
    if(value < 'a' || value > 'j')
        printk("Invalid Value\n");
    else
        pwm_config(pwm0, 100000000 * (value - 'a'), 1000000000);

    /* Calculate data */
    delta = to_copy - not_copied;

    return delta;
}

/**
 * @brief This function is called, when the device file is opened
 */
static int driver_open(struct inode *device_file, struct file *instance) {
    printk("dev_nr - open was called!\n");
    return 0;
}

/**
 * @brief This function is called, when the device file is opened
 */
static int driver_close(struct inode *device_file, struct file *instance) {
    printk("dev_nr - close was called!\n");
    return 0;
}

static struct file_operations fops = {
    .owner = THIS_MODULE,
    .open = driver_open,
    .release = driver_close,
    .write = driver_write
};

/**
 * @brief This function is called, when the module is loaded into the kernel
 */
static int __init ModuleInit(void) {
    printk("Hello, Kernel!\n");

    /* Allocate a device nr */
    if( alloc_chrdev_region(&my_device_nr, 0, 1, DRIVER_NAME) < 0) {
        printk("Device Nr. could not be allocated!\n");
        return -1;
    }
    printk("read_write - Device Nr. Major: %d, Minor: %d was registered!\n", my_device_nr >> 20, my_device_nr && 0xfffff);

    /* Create device class */
    if((my_class = class_create(THIS_MODULE, DRIVER_CLASS)) == NULL) {
        printk("Device class can not be created!\n");
        goto ClassError;
    }

    /* create device file */
    if(device_create(my_class, NULL, my_device_nr, NULL, DRIVER_NAME) == NULL) {
        printk("Can not create device file!\n");
        goto FileError;
    }

    /* Initialize device file */
    cdev_init(&my_device, &fops);

    /* Regisering device to kernel */
    if(cdev_add(&my_device, my_device_nr, 1) == -1) {
        printk("Registering of device to kernel failed!\n");
        goto AddError;
    }

    pwm0 = pwm_request(0, "my-pwm");
    if(pwm0 == NULL) {
        printk("Could not get PWM0!\n");
        goto AddError;
    }

    pwm_config(pwm0, pwm_on_time, 1000000000);
    pwm_enable(pwm0);

    return 0;
AddError:
    device_destroy(my_class, my_device_nr);
FileError:
    class_destroy(my_class);
ClassError:
    unregister_chrdev_region(my_device_nr, 1);
    return -1;
}

/**
 * @brief This function is called, when the module is removed from the kernel
 */
static void __exit ModuleExit(void) {
    pwm_disable(pwm0);
    pwm_free(pwm0);
    cdev_del(&my_device);
    device_destroy(my_class, my_device_nr);
    class_destroy(my_class);
    unregister_chrdev_region(my_device_nr, 1);
    printk("Goodbye, Kernel\n");
}

module_init(ModuleInit);
module_exit(ModuleExit);
\end{mycode}

Makefile如下

\begin{mycode}{Makefile}
obj-m += pwm_driver.o

all:
    make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules

clean:
    make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean
\end{mycode}

\chapter{LCD驱动示例}

\begin{mycode}{lcd\_driver.c}
#include <linux/module.h>
#include <linux/version.h>
#include <linux/init.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/uaccess.h>
#include <linux/gpio.h>
#include <linux/delay.h>

/* Meta Information */
MODULE_LICENSE("GPL");
MODULE_AUTHOR("Johannes 4 GNU/Linux");
MODULE_DESCRIPTION("A driver to write to a LCD text display");

/* Variables for device and device class */
static dev_t my_device_nr;
static struct class *my_class;
static struct cdev my_device;

#define DRIVER_NAME "lcd"
#define DRIVER_CLASS "MyModuleClass"

/* LCD char buffer */
static char lcd_buffer[17];

/* Pinout for LCD Display */
unsigned int gpios[] = {
    3, /* Enable Pin */
    2, /* Register Select Pin */
    4, /* Data Pin 0*/
    17, /* Data Pin 1*/
    27, /* Data Pin 2*/
    22, /* Data Pin 3*/
    10, /* Data Pin 4*/
    9, /* Data Pin 5*/
    11, /* Data Pin 6*/
    5, /* Data Pin 7*/
};

#define REGISTER_SELECT gpios[1]

/**
 * @brief generates a pulse on the enable signal
 */
void lcd_enable(void) {
    gpio_set_value(gpios[0], 1);
    msleep(5);
    gpio_set_value(gpios[0], 0);
}

/**
 * @brief set the 8 bit data bus
 * @param data: Data to set
 */
void lcd_send_byte(char data) {
    int i;
    for(i=0; i<8; i++)
        gpio_set_value(gpios[i+2], ((data) & (1<<i)) >> i);
    lcd_enable();
    msleep(5);
}

/**
 * @brief send a command to the LCD
 *
 * @param data: command to send
 */
void lcd_command(uint8_t data) {
     gpio_set_value(REGISTER_SELECT, 0);    /* RS to Instruction */
    lcd_send_byte(data);
}

/**
 * @brief send a data to the LCD
 *
 * @param data: command to send
 */
void lcd_data(uint8_t data) {
     gpio_set_value(REGISTER_SELECT, 1);    /* RS to data */
    lcd_send_byte(data);
}


/**
 * @brief Write data to buffer
 */
static ssize_t driver_write(struct file *File, const char *user_buffer, size_t count, loff_t *offs) {
    int to_copy, not_copied, delta, i;

    /* Get amount of data to copy */
    to_copy = min(count, sizeof(lcd_buffer));

    /* Copy data to user */
    not_copied = copy_from_user(lcd_buffer, user_buffer, to_copy);

    /* Calculate data */
    delta = to_copy - not_copied;

    /* Set the new data to the display */
    lcd_command(0x1);

    for(i=0; i<to_copy; i++)
        lcd_data(lcd_buffer[i]);

    return delta;
}

/**
 * @brief This function is called, when the device file is opened
 */
static int driver_open(struct inode *device_file, struct file *instance) {
    printk("dev_nr - open was called!\n");
    return 0;
}

/**
 * @brief This function is called, when the device file is opened
 */
static int driver_close(struct inode *device_file, struct file *instance) {
    printk("dev_nr - close was called!\n");
    return 0;
}

static struct file_operations fops = {
    .owner = THIS_MODULE,
    .open = driver_open,
    .release = driver_close,
    .write = driver_write
};

/**
 * @brief This function is called, when the module is loaded into the kernel
 */
static int __init ModuleInit(void) {
    int i;
    char *names[] = {"ENABLE_PIN", "REGISTER_SELECT", "DATA_PIN0", "DATA_PIN1", "DATA_PIN2", "DATA_PIN3", "DATA_PIN4", "DATA_PIN5", "DATA_PIN6", "DATA_PIN7"};
    printk("Hello, Kernel!\n");

    /* Allocate a device nr */
    if( alloc_chrdev_region(&my_device_nr, 0, 1, DRIVER_NAME) < 0) {
        printk("Device Nr. could not be allocated!\n");
        return -1;
    }
    printk("read_write - Device Nr. Major: %d, Minor: %d was registered!\n", my_device_nr >> 20, my_device_nr && 0xfffff);

    /* Create device class */
    if((my_class = class_create(THIS_MODULE, DRIVER_CLASS)) == NULL) {
        printk("Device class can not be created!\n");
        goto ClassError;
    }

    /* create device file */
    if(device_create(my_class, NULL, my_device_nr, NULL, DRIVER_NAME) == NULL) {
        printk("Can not create device file!\n");
        goto FileError;
    }

    /* Initialize device file */
    cdev_init(&my_device, &fops);

    /* Regisering device to kernel */
    if(cdev_add(&my_device, my_device_nr, 1) == -1) {
        printk("lcd-driver - Registering of device to kernel failed!\n");
        goto AddError;
    }

    /* Initialize GPIOs */
    printk("lcd-driver - GPIO Init\n");
    for(i=0; i<10; i++) {
        if(gpio_request(gpios[i], names[i])) {
            printk("lcd-driver - Error Init GPIO %d\n", gpios[i]);
            goto GpioInitError;
        }
    }

    printk("lcd-driver - Set GPIOs to output\n");
    for(i=0; i<10; i++) {
        if(gpio_direction_output(gpios[i], 0)) {
            printk("lcd-driver - Error setting GPIO %d to output\n", i);
            goto GpioDirectionError;
        }
    }

    /* Init the display */
    lcd_command(0x30);    /* Set the display for 8 bit data interface */

    lcd_command(0xf);    /* Turn display on, turn cursor on, set cursor blinking */

    lcd_command(0x1);

    char text[] = "Hello World!";
    for(i=0; i<sizeof(text)-1;i++)
        lcd_data(text[i]);

    return 0;
GpioDirectionError:
    i=9;
GpioInitError:
    for(;i>=0; i--)
        gpio_free(gpios[i]);
AddError:
    device_destroy(my_class, my_device_nr);
FileError:
    class_destroy(my_class);
ClassError:
    unregister_chrdev_region(my_device_nr, 1);
    return -1;
}

/**
 * @brief This function is called, when the module is removed from the kernel
 */
static void __exit ModuleExit(void) {
    int i;
    lcd_command(0x1);    /* Clear the display */
    for(i=0; i<10; i++){
        gpio_set_value(gpios[i], 0);
        gpio_free(gpios[i]);
    }
    cdev_del(&my_device);
    device_destroy(my_class, my_device_nr);
    class_destroy(my_class);
    unregister_chrdev_region(my_device_nr, 1);
    printk("Goodbye, Kernel\n");
}

module_init(ModuleInit);
module_exit(ModuleExit);
\end{mycode}

\begin{mycode}{Makefile}
obj-m += lcd_driver.o

all:
    make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules

clean:
    make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean
\end{mycode}

\chapter{I2C驱动程序示例}



\end{document}
